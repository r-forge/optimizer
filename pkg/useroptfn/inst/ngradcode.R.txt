# The following code chunk should be put inside an optimizer to compute
#    gradient approximations. 
# The code defines WHICH code to use. 
# ??? Why can we not make this run in a package external to optimizer??
#  J C Nash 2011-7-2
#
# Variables assumed available
#
#  gr
#  dowarn
#  ctrl[["usenumDeriv"]]
#  fn
#  eps
#
    #############################################
    # local function defined only when user does not specify a
    #   gr
    # Simple gr numerical approximation. Using fn, fmin and eps
    #   from calling env.
    if (is.null(gr)) 
        { # Use initial fn to define gradients, then apply maximize in fnuser 110702
            if (dowarn) 
                warning("Numerical gradients may be inappropriate for Rvmmin")
            if (ctrl[["usenumDeriv"]]) {
                # external gradient
                require(numDeriv)
                gr <- function(par, ...) {
                  gg <- grad(fn, par, ...)
                  gg[which((!is.finite(gg)) || (is.nan(gg)))] <- 0
                  gg
                }
            }
            else {
                # using local gradient
                gr <- function(par, ...) {
                  fbase <- fn(par, ...)  # ensure we have right value, may not be necessary
                  df <- rep(NA, length(par))
                  teps <- eps * (abs(par) + eps)
                  for (i in 1:length(par)) {
                    dx <- par
                    dx[i] <- dx[i] + teps[i]
                    tdf <- (fn(dx, ...) - fbase)/teps[i]
                    if (!is.finite(tdf) || is.nan(tdf)) 
                      tdf <- 0  # ??? choice
                    df[i] <- tdf
                  }
                  df
                }
            }  # end else
        }  # is.null(gr)
    ############# end gr ########################
    fnuser<-list(fn=fn, gr=gr, hess=NULL) # define the user function
    #############################################

