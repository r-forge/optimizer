<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="John C. Nash and Paul Gilbert" />

<meta name="date" content="2016-11-17" />

<title>A structure for building and running optimization and nonlinear least squares tests for R</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">A structure for building and running optimization and nonlinear least squares tests for <strong>R</strong></h1>
<h4 class="author"><em>John C. Nash and Paul Gilbert</em></h4>
<h4 class="date"><em>2016-11-17</em></h4>



<div id="abstract" class="section level2">
<h2>Abstract</h2>
<p>This article discusses how tests for nonlinear equations, least squares or equations may be set up, executed and analyzed for <strong>R</strong>. This activity is sensitive to the manner in which the test functions are computed, the choice of starting values, and the choice of measures of success. They may also be modified by changes in the solvers for the problems in question. Indeed, it is always a concern that seemingly minor adjustments intended to improve such solvers may cause them to fail on particular problems or starting values. Thus it is desirable to be able to</p>
<ul>
<li><p>be able to quickly and easily run a specific test on all available solvers;</p></li>
<li><p>be able to quickly and easily run all available tests on an updated or new solver;</p></li>
<li><p>be able to report successes and failures in a manner that allows for rapid detection of potential issues with solvers.</p></li>
</ul>
<p>The last criterion requires that there be a way to save and access the results of test runs. Because each test instance can generate quite a lot of data, and the combinatorial possibilities of tests, solvers, and solver options such as choice of gradient approximation, saving test information could demand considerable storage space and data management effort. We outline some possible approaches to the data management aspect of optimization testing.</p>
</div>
<div id="section" class="section level1">
<h1></h1>
<div id="motivation" class="section level2">
<h2>Motivation</h2>
<p><a href="http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml" class="uri">http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml</a> presents a number of nonlinear regression (nonlinear least squares) problems that are more or less difficult to solve numerically. Doug Bates prepared an <strong>R</strong> package <code>NISTnls</code> which adapted these problems to <strong>R</strong> and tested them with the <code>nls()</code> function of which he was a major author. There are a number of other test function collections (some referenced below), usually with overlap in their coverage, for nonlinear equations, nonlinear least squares and function minimization. In some cases, such tests include bounds constraints or fixed parameters.</p>
<p>In 2009, I built the incomplete package <code>NISTopt</code> to allow the same problems as in <code>NISTnls</code> to be approached as unconstrained function minimization problems. Similarly, the Google Summer of Code project OptimGUI by Yixuan Qiu in 2011 attempted to provide a point-and-click interface to aid in building and running function minimization problems in <strong>R</strong>, and developed a structure for storing such problems in a consistent manner. This vignette is an attempt to better document such ideas. It is especially concerned with how to <strong>efficiently</strong> add, modify, run and review tests of the <strong>R</strong> tools to solve such problems.</p>
<p>Note that the test problems used are <strong>NOT</strong> always good illustrations of the tasks to which the various function minimization tools should be applied by general <strong>R</strong> users. However, they do suggest limits of performance of these tools.</p>
<p>We note that in <strong>R</strong> circles, function minimization is often called “optimization”, though that generally implies that there are also constraints.</p>
</div>
<div id="approach" class="section level2">
<h2>Approach</h2>
<p>We want to avoid having to write specific code to run each test. The package <strong>optimrx</strong> (??citation) can call most of the function minimization tools in <strong>R</strong> and can be extended to include others, and the functions within this package standardize the call to each of the minimization solvers. Thus we can simplify the code to test such solvers, using only their method name within the calls to either <code>optimr()</code> or <code>opm()</code>. Furthermore, these functions allow a consistent syntax for specifying analytic gradients (if available), the built-in gradient approximation (if this is part of the solver), else one of several pre-defined gradient approximations callable in the <strong>optextras</strong> package. At the time of writing, an effort is in process to try to similarly unify the nonlinear least squares tools for <strong>R</strong>, namely, the <code>nls()</code> function in the <strong>stats</strong> package, and the tools in packages <strong>nlmrt</strong>, <strong>minpack.lm</strong> and <strong>nls2</strong> as well as some new efforts.</p>
<div id="specification-of-problems" class="section level3">
<h3>Specification of problems</h3>
<p>Code developed in the trial package <strong>NISTopt</strong> suggested that a given problem could be specified by a particular name. Thus, the problem of <span class="citation">Daniel and Wood (1980)</span>, is called <strong>DanielWood</strong>. If we wish to solve it using one of the nonlinear least squares solvers that use a syntax like that of <code>nls()</code>, then we need to provide a model formula and some data that is consistent with this model formula. By naming the formula as <code>DanielWood.formula</code>, and putting the data in a dataframe named <code>DanielWood.df</code>, we then need only a starting vector of parameters to have a well-specified formula-based nonlinear least squares problem. Besides <code>nls()</code>, <code>nlxb()</code> from <strong>nlmrt</strong>, <code>nls2()</code> from <strong>nls2</strong> (CRAN version), and <code>nls.lm</code> from <strong>minpack.lm</strong>.</p>
<p>Similarly, a function-based nonlinear least squares problem solvable by <code>nlfb()</code> from package <strong>nlmrt</strong> or <code>nlsLM</code> from <strong>minpack.lm</strong> can be specified by an <strong>R</strong> function that computes the residual vector from a particular set of parameters. These functions can also use a Jacobian function if it is available. At the time of writing, an approximate Jacobian will be provided by these solvers if the provided argument is NULL. Work is in process to try to provide particular derivative approximations by a mechanism similar to the one used in package <strong>optimrx</strong>. We can provide for use of such solvers by using the name <code>DanielWood.res</code> for the residual function and <code>DanielWood.jac</code> for the Jacobian.</p>
<p>Finally, for function minimization, we can specify <code>DanielWood.f</code> for a general function to be minimized, with the (optional) <code>DanielWood.g</code> for the gradient.</p>
<p>Many optimization problems, including some test problems, need data other than the parameters. This can be provided by <code>DanielWood.setup</code>. This function will, if required, create the dataframe for nonlinear least squares solvers.</p>
<p>There are often several sets of starting parameters for given test problems, as well as the possibility of generated pseudo-random vectors, especially for those problems which have a variable number of parameters. These can be provided in a matrix called <code>starts</code> which has named columns, since the nonlinear least squares solvers using a model formula require parameter names. When the problem has no model formula, we can and do provide parameter names as <code>p1, p2, ..., pn</code>. (?? not done yet, but it is in opm() already) The specification of starting parameters will be part of the <code>.setup</code> function.</p>
<p>Note that the <code>.res</code> function can be used to specify nonlinear equations problems if the solution has all the residuals at zero. At the time of writing, we have not yet included this possibility.</p>
</div>
<div id="restrictions-on-the-problems" class="section level3">
<h3>Restrictions on the problems</h3>
<p>We do not wish (at the moment) to include general optimization problems with general constraints. In fact, we will limit our attention to at most bounds constrained nonlinear optimization and nonlinear least squares problems. There are, however, a lot of these. By considering lower and upper bounds that are equal, we can extend the constraints to fixed or <strong>masked</strong> parameters.</p>
</div>
</div>
<div id="design-i" class="section level2">
<h2>Design I</h2>
<p>Building on the ideas of the above section, we create the example <strong>problem file</strong> <code>DanielWood.prb</code>. In this case, we provide all the elements above. Thus we have a <strong>set</strong> of problems, all of which can be accessed through a single structure. Through some experiments, detailed in <em>Appendix A: Use of a data frame</em>, we found that one could, if desired, store such problems in a data frame, but this seems overly complicated. Our flat, plain text files, one per named problem, should suffice. Other structures are, of course, equally possible. However, we will experiment with the current approach until we discover it cannot support our requirements.</p>
<div id="the-danielwood-problem" class="section level3">
<h3>The <strong>DanielWood</strong> problem</h3>
<p>Let us implement, in <strong>R</strong>, a possible file for the problem of <span class="citation">Daniel and Wood (1980)</span>.</p>
<pre><code>## Loading required package: knitr</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># This is file DanielWood.prb</span>
probname &lt;-<span class="st"> &quot;DanielWood&quot;</span>
probdesc &lt;-<span class="st"> &quot;These data and model are described in Daniel and Wood (1980), and</span>
<span class="st">originally published in E.S.Keeping, 'Introduction to Statistical Inference,'</span>
<span class="st">Van Nostrand Company, Princeton, NJ, 1962, p. 354. The response variable is </span>
<span class="st">energy radieted from a carbon filament lamp per cm**2 per second, and the </span>
<span class="st">predictor variable is the absolute temperature of the filament in 1000 degrees Kelvin. </span>
<span class="st">&quot;</span>
<span class="co">#- setup</span>
DanielWood.setup&lt;-function() {
y &lt;-<span class="st"> </span><span class="kw">c</span>( <span class="fl">2.138</span>, <span class="fl">3.421</span>, <span class="fl">3.597</span>, <span class="fl">4.340</span>, <span class="fl">4.882</span>, <span class="fl">5.660</span>)
x &lt;-<span class="st"> </span><span class="kw">c</span>( <span class="fl">1.309</span>, <span class="fl">1.471</span>, <span class="fl">1.490</span>, <span class="fl">1.565</span>, <span class="fl">1.611</span>, <span class="fl">1.680</span>)
DanielWood.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(x,y)
<span class="kw">rm</span>(x)
<span class="kw">rm</span>(y)
start1 =<span class="st"> </span><span class="kw">c</span>(<span class="dt">b1=</span> <span class="dv">1</span>, <span class="dt">b2 =</span> <span class="dv">5</span>)
start2 =<span class="st"> </span><span class="kw">c</span>(<span class="dt">b1 =</span> <span class="fl">0.7</span>,<span class="dt">b2 =</span> <span class="dv">4</span>)
starts &lt;-<span class="st"> </span><span class="kw">rbind</span>(start1, start2)
probtype &lt;-<span class="st"> &quot;nls&quot;</span> <span class="co"># nls offers more possibilities than function minimization</span>
<span class="co">#- Other types??  &quot;fmin&quot;, &quot;ssmin&quot; (for resid ss)</span>
mformula &lt;-<span class="st"> </span>( y ~<span class="st"> </span>b1*x**b2 )
<span class="co">#- The above is a &quot;formula&quot;. But we could also possibl also use a character string or expression,</span>
<span class="co">#- but need to know how to do so carefully. ??</span>
out&lt;-<span class="kw">list</span>(<span class="dt">starts=</span>starts, <span class="dt">df=</span>DanielWood.df, <span class="dt">mformula=</span>mformula, <span class="dt">probtype=</span>probtype)
<span class="co">#- return(out)</span>
}
##- ?? mdata=DanielWood # This would work if we have a data package, but not useful independently
<span class="co">#- This is the local data frame. We need to rename this when we put it into a global structure</span>
<span class="co">#- Now add various functions for optimization or nls-by-function</span>
<span class="co">#- ?? We could have problems with quotation marks WITHIN the code.</span>

DanielWood.f &lt;-<span class="st"> </span>function(x) {
res&lt;-<span class="kw">DanielWood.res</span>(x)
f&lt;-<span class="kw">sum</span>(res*res)
}

<span class="co">#- resfn</span>
DanielWood.res &lt;-<span class="st"> </span>function(b) {
xx&lt;-DanielWood.df$x <span class="co"># case !!</span>
yy&lt;-DanielWood.df$y
res &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(xx))
b1&lt;-b[<span class="dv">1</span>]
b2&lt;-b[<span class="dv">2</span>]
res&lt;-b1*(xx**b2) -<span class="st"> </span>yy
<span class="kw">return</span>(res)
}

<span class="co">#- jacfn</span>
<span class="co"># DanielWood - Jacobian</span>
DanielWood.jac &lt;-<span class="st"> </span>function(b) {
xx&lt;-DanielWood.df$x
yy&lt;-DanielWood.df$y
n&lt;-<span class="kw">length</span>(b)
m&lt;-<span class="kw">length</span>(xx)
b1&lt;-b[<span class="dv">1</span>]
b2&lt;-b[<span class="dv">2</span>]
J&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,m,n) <span class="co"># define the size of the Jacobian</span>
expr1 &lt;-<span class="st"> </span>xx^b2
J[, <span class="dv">1</span>] &lt;-<span class="st"> </span>expr1
J[, <span class="dv">2</span>] &lt;-<span class="st"> </span>b1 *<span class="st"> </span>(expr1 *<span class="st"> </span><span class="kw">log</span>(xx))
<span class="kw">return</span>(J)
}

<span class="co">#- hessfn</span>
DanielWood.h &lt;-<span class="st"> </span>function(x) {
JJ&lt;-<span class="kw">DanielWood.jac</span>(x)
H &lt;-<span class="st"> </span><span class="kw">t</span>(JJ) %*%<span class="st"> </span>JJ
res&lt;-<span class="kw">DanielWood.res</span>(x)
}

<span class="co">#- gr</span>
DanielWood.g&lt;-function(x) {
<span class="co">#-   stop('not defined')</span>
JJ&lt;-<span class="kw">DanielWood.jac</span>(x)
res&lt;-<span class="kw">DanielWood.res</span>(x)
gg&lt;-<span class="kw">as.vector</span>(<span class="fl">2.0</span>*<span class="kw">t</span>(JJ) %*%<span class="st"> </span>res)
<span class="kw">return</span>(gg)
}


<span class="co">#- pstart &lt;- c(b1= 1, b2 = 5) # fix later for more starts</span>

DanielWood.test&lt;-function() {
}   </code></pre></div>
</div>
</div>
<div id="tools-for-preparing-and-using-problem-files" class="section level2">
<h2>Tools for preparing and using problem files</h2>
<div id="access-to-files" class="section level3">
<h3>Access to files</h3>
<p>In order to use problem files, we need a way to list them, display their content in both summary and detail, and attempt to use them with various nonlinear least squares and/or function minimization software.</p>
<div id="command-line-file-lister-and-display-tool" class="section level4">
<h4>Command line file lister and display tool</h4>
<p>We need a tool that</p>
<ul>
<li><p>sets the directory where problems are found</p></li>
<li><p>lists the files</p></li>
<li><p>allows one file to be selected</p></li>
<li><p>displays information in a structured way (possibly according to some profile)</p></li>
<li><p>allows the profile for display to be edited somehow</p></li>
</ul>
<p>?? code here</p>
</div>
<div id="gui-file-lister-and-display-tool" class="section level4">
<h4>GUI file lister and display tool</h4>
<p>Likely tied into command line tool by allowing command line to be executed when mouse or pointer clicks are executed. Check existing GUI tools to see what is possible.</p>
<p>?? code here</p>
</div>
</div>
<div id="building-problem-files" class="section level3">
<h3>Building problem files</h3>
<div id="data-frame-or-matrix-to-source-vector" class="section level4">
<h4>Data frame or matrix to source vector</h4>
<p>If problem files are to be self contained, we do not want to need to access external files. The simplest way to present a variable to <strong>R</strong> is to input data as a simple list and then name it. To prepare the problem file, we therefore want to be able to get data into the local <strong>R</strong> environment and prepare the text for an assignment statement that contains a source vector.</p>
<p>?? code</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Use paste() to build the c(...) structure</span></code></pre></div>
</div>
</div>
</div>
<div id="running-problems" class="section level2">
<h2>Running problems</h2>
<p><code>runoptprob</code> – ?? how it should be used</p>
<ul>
<li><p>provide</p>
<p>– filename (at least the root)</p>
<p>– which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)</p>
<p>– choice of gradient function or approximation (gr= (gr, “grfwd”, etc.)) ?? optional?</p>
<p>– controls – as per the control list in programs</p>
<p>– other arguments ?? how to provide? dotargs as below?</p>
<p>– xdata or dotargs (how to specify might be interesting)</p>
<p>– timing control (e.g., microbenchmark or simple timing)</p></li>
<li><p>read output control profile (initially just use sink())</p></li>
<li><p>read the file and execute it (make sure it has <strong>R</strong> commands so we can actually source() it)</p></li>
<li><p>analyze the call to runprob and do the appropriate call</p></li>
<li><p>format output and extract and store summaries</p></li>
</ul>
<p>– this may be multilayerd and take a lot of work</p>
<p>– start with no formatting, and gradually add features</p>
<p>– need to save conditions</p>
<p>– make sure we have time/date stamp on all runs</p>
<p>Issues to address?? : - sink() will save information, but there is a cost in time and space - how to do ok/not or red/yellow/green nicely | Do we want on params and value? - dealing with multiple solutions – linear combination defined - where to put setting of FUZZ, reporting of deviations</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(nlmrt, <span class="dt">quietly=</span><span class="ot">TRUE</span>)
<span class="kw">require</span>(optimrx, <span class="dt">quietly=</span><span class="ot">TRUE</span>)
runoptprob &lt;-<span class="st"> </span>function(pfilename, <span class="dt">minmeth=</span><span class="ot">NULL</span>, <span class="dt">submeth=</span><span class="ot">NULL</span>, <span class="dt">nstart=</span><span class="dv">0</span>, 
                 <span class="dt">runopts=</span><span class="kw">list</span>(), <span class="dt">control=</span><span class="kw">list</span>(), ...) {

  <span class="co">#- ?? Need to eval(parse()) ALL functions available, since f calls res etc.</span>
  <span class="co">#- Need to carefully ensure these exist to avoid errors??</span>
  <span class="co">#- ?? can we simplify and NOT have to eval(parse()) them, but simply source the prb file?</span>
  
  <span class="kw">print</span>(runopts)
  <span class="kw">print</span>(control)
  optecho &lt;-<span class="st"> </span><span class="ot">TRUE</span> <span class="co"># temporarily at least, or put in a profile</span>
  <span class="co">#- Get the path to the files (where should these be? Probably somehow related to pkg)   </span>
  pfile &lt;-<span class="st"> </span><span class="kw">paste</span>(pfilename, <span class="st">&quot;.prb&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)

  starts &lt;-<span class="st"> </span><span class="ot">NA</span>
  mformula &lt;-<span class="st"> </span><span class="ot">NA</span> <span class="co"># Make sure these are defined (they get set up in pfile)</span>
<span class="co">#- ?? need to figure out dynamic setting of paths</span>
  pfilepath &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;/home/john/rsvnall/optimizer/pkg/NISTO/inst/extdata/&quot;</span>,pfile,<span class="dt">sep=</span><span class="st">''</span>)
  <span class="kw">source</span>(pfilepath, <span class="dt">echo=</span>optecho) <span class="co"># -- filename (at least the root)</span>
  <span class="kw">cat</span>(<span class="st">&quot;Objects in workspace:</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">print</span>(<span class="kw">ls</span>())

  <span class="co">#- now have a lot of the information</span>
  
  <span class="co">#-    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)</span>
  
  <span class="co">#-    -- choice of gradient function or approximation (gr= (gr, &quot;grfwd&quot;, etc.))</span>
  
  <span class="co">#-    -- controls -- as per the control list in programs</span>
  
  <span class="co">#-    -- other arguments</span>
  
  <span class="co">#-    -- xdata or dotargs (how to specify might be interesting)</span>
  
  <span class="co">#-    -- timing control (e.g., microbenchmark or simple timing)</span>
  
  <span class="co">#-  - read output control profile (initially just use sink())</span>
  <span class="co">#-  -- make sure we have time/date stamp on all runs</span>
  fname&lt;-<span class="kw">paste</span>(pfilename, <span class="kw">format</span>(<span class="kw">Sys.time</span>(), <span class="st">&quot;%Y%m%d%H%M&quot;</span>),<span class="st">&quot;.out&quot;</span>,<span class="dt">sep=</span><span class="st">''</span>)
  <span class="co">#- ?? not created until later, then conditionally </span>
  <span class="co">#- ?? sink(fname, append=TRUE, split=TRUE)</span>
  
  <span class="co">#-  - read the file and execute it (make sure it has **R** commands so we can</span>
  <span class="co">#-   actually source() it)</span>
  setupfn &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.setup&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>))) <span class="co">#- setup function</span>
  pdat &lt;-<span class="st"> </span><span class="kw">setupfn</span>()
  <span class="kw">cat</span>(<span class="st">&quot;pdat:</span><span class="ch">\n</span><span class="st">&quot;</span>)
  <span class="kw">print</span>(pdat)
  <span class="co">#- get the data and the starts</span>
  <span class="kw">print</span>(pdat$df)
  dfname &lt;-<span class="st"> </span>pdat$df
  starts &lt;-<span class="st"> </span>pdat$starts
  mformula &lt;-<span class="st"> </span>pdat$mformula ##?? later on simplify and remove extra lines 
  <span class="co">#- - analyze the call to runprob and do the appropriate call</span>
  
  <span class="co">#- - format output and extract and store summaries</span>
  
  <span class="co">#-  -- this may be multilayerd and take a lot of work</span>
  
  <span class="co">#-  -- start with no formatting, and gradually add features</span>
  
  <span class="co">#-  -- need to save conditions</span>
  if (nstart ==<span class="st"> </span><span class="dv">0</span>) { <span class="co"># need to loop</span>
    <span class="kw">cat</span>(<span class="st">&quot;nstart == 0 </span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">print</span>(pdat$starts)
    nst &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, (<span class="kw">dim</span>(pdat$starts)[<span class="dv">1</span>]))
  } else { nst &lt;-<span class="st"> </span>nstart }
  if (minmeth ==<span class="st"> 'nls'</span>) {
    for (istrt in nst){
      <span class="co">#- ?? need to extract options and arguments like trace</span>
      <span class="co">#- some documentation output needed ??</span>
      sol &lt;-<span class="st"> </span><span class="kw">nls</span>(mformula, <span class="dt">data=</span>dfname, <span class="dt">start=</span>starts[istrt,], <span class="dt">trace=</span><span class="ot">TRUE</span>)      
      <span class="kw">print</span>(sol)
      <span class="kw">print</span>(<span class="kw">summary</span>(sol))
    }    
  }  
  if (minmeth ==<span class="st"> 'nlxb'</span>) {
##??      require(nlmrt)
      for (istrt in nst){
      <span class="co">#- ?? need to extract options and arguments like trace</span>
      <span class="co">#- some documentation output needed ??</span>
      sol &lt;-<span class="st"> </span><span class="kw">nlxb</span>(mformula, <span class="dt">data=</span>dfname, <span class="dt">start=</span>starts[istrt,], <span class="dt">trace=</span><span class="ot">TRUE</span>)      
      <span class="kw">print</span>(sol)
      <span class="kw">print</span>(<span class="kw">summary</span>(sol))
    }    
  }  
  if (minmeth ==<span class="st"> &quot;optimr&quot;</span>) {
## ??     require(optimrx) #- ?? optimr for CRAN
    <span class="co">#- here need to check if they exist??</span>
     ufn &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.f&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.res&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.jac&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.g&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     if( <span class="kw">is.null</span>(runopts$gr) ||<span class="st"> </span>!<span class="st"> </span><span class="kw">is.character</span>(runopts$gr) ) {
<span class="co">#       #- name.gr now a function      </span>
       ugr &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.g&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     } else { ugr &lt;-<span class="st"> </span>(runopts$gr) }
     ufn &lt;-<span class="st">  </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.f&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     for (istrt in nst){
        sol &lt;-<span class="st"> </span><span class="kw">optimr</span>(starts[istrt,], ufn, ugr, <span class="dt">method=</span>submeth, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">trace=</span><span class="dv">1</span>))
        <span class="kw">print</span>(sol)
     }
  }
    <span class="co">#- result should be a list of things run</span>
  <span class="co">#- ?? sink() # should make conditional and not usually do this, else delete after asking</span>
  testsol &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">pfilename=</span>pfilename, <span class="dt">nstart=</span>nstart, <span class="dt">minmeth=</span>minmeth, <span class="dt">submeth=</span>submeth)
<span class="co">#- ?? definitely need more stuff returned</span>
}</code></pre></div>
</div>
<div id="running-multiple-problems" class="section level2">
<h2>Running multiple problems</h2>
<ul>
<li><p>prepare “problem list”, like a play list</p></li>
<li><p>run them in sequence</p></li>
<li><p>try to figure out how to save the output</p>
<p>– sink</p>
<p>– summaries</p>
<p>– test against expected output</p>
<p>– timings</p>
<p>– measures of success</p></li>
</ul>
<p>For the moment, let us just call runoptprob(). Note that it creates a sinkfile for each call.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pfname &lt;-<span class="st"> &quot;DanielWood&quot;</span>
<span class="co"># try it</span>
test1 &lt;-<span class="st"> </span><span class="kw">runoptprob</span>(<span class="dt">pfilename=</span>pfname, <span class="dt">minmeth=</span><span class="st">&quot;nls&quot;</span>)</code></pre></div>
<pre><code>## list()
## list()
## 
## &gt; probname &lt;- &quot;DanielWood&quot;
## 
## &gt; probdesc &lt;- &quot;These data and model are described in Daniel and Wood (1980), and\noriginally published in E.S.Keeping, 'Introduction to Statistical In ...&quot; ... [TRUNCATED] 
## 
## &gt; DanielWood.setup &lt;- function() {
## +     y &lt;- c(2.138, 3.421, 3.597, 4.34, 4.882, 5.66)
## +     x &lt;- c(1.309, 1.471, 1.49, 1.565, 1.611, 1.68)
## +     Dan .... [TRUNCATED] 
## 
## &gt; DanielWood.f &lt;- function(x) {
## +     res &lt;- DanielWood.res(x)
## +     f &lt;- sum(res * res)
## + }
## 
## &gt; DanielWood.res &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     res &lt;- rep(NA, length(xx))
## +     b1 &lt;- b[1]
## +     b2 &lt; .... [TRUNCATED] 
## 
## &gt; DanielWood.jac &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     n &lt;- length(b)
## +     m &lt;- length(xx)
## +     b1 &lt;- b[1]
##  .... [TRUNCATED] 
## 
## &gt; DanielWood.h &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     H &lt;- t(JJ) %*% JJ
## +     res &lt;- DanielWood.res(x)
## + }
## 
## &gt; DanielWood.g &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     res &lt;- DanielWood.res(x)
## +     gg &lt;- as.vector(2 * t(JJ) %*% res)
## +     return(gg) .... [TRUNCATED] 
## 
## &gt; DanielWood.test &lt;- function() {
## + }
## Objects in workspace:
##  [1] &quot;control&quot;   &quot;mformula&quot;  &quot;minmeth&quot;   &quot;nstart&quot;    &quot;optecho&quot;  
##  [6] &quot;pfile&quot;     &quot;pfilename&quot; &quot;pfilepath&quot; &quot;runopts&quot;   &quot;starts&quot;   
## [11] &quot;submeth&quot;  
## pdat:
## $starts
##         b1 b2
## start1 1.0  5
## start2 0.7  4
## 
## $df
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## 
## $mformula
## y ~ b1 * x^b2
## &lt;environment: 0x21dea68&gt;
## 
## $probtype
## [1] &quot;nls&quot;
## 
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## nstart == 0 
##         b1 b2
## start1 1.0  5
## start2 0.7  4
## 149.7192 :  1 5
## 4.610878 :  0.7061691 4.4567375
## 0.03168417 :  0.7499191 3.9483634
## 0.004320594 :  0.7685973 3.8607752
## 0.004317308 :  0.7688633 3.8604026
## 0.004317308 :  0.7688623 3.8604056
## Nonlinear regression model
##   model: y ~ b1 * x^b2
##    data: dfname
##     b1     b2 
## 0.7689 3.8604 
##  residual sum-of-squares: 0.004317
## 
## Number of iterations to convergence: 5 
## Achieved convergence tolerance: 2.529e-07
## 
## Formula: y ~ b1 * x^b2
## 
## Parameters:
##    Estimate Std. Error t value Pr(&gt;|t|)    
## b1  0.76886    0.01828   42.06 1.91e-06 ***
## b2  3.86041    0.05173   74.63 1.93e-07 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.03285 on 4 degrees of freedom
## 
## Number of iterations to convergence: 5 
## Achieved convergence tolerance: 2.529e-07
## 
## 0.1037647 :  0.7 4.0
## 0.005930406 :  0.7679852 3.8542844
## 0.004317316 :  0.7688429 3.8604767
## 0.004317308 :  0.7688625 3.8604050
## Nonlinear regression model
##   model: y ~ b1 * x^b2
##    data: dfname
##     b1     b2 
## 0.7689 3.8604 
##  residual sum-of-squares: 0.004317
## 
## Number of iterations to convergence: 3 
## Achieved convergence tolerance: 5.447e-06
## 
## Formula: y ~ b1 * x^b2
## 
## Parameters:
##    Estimate Std. Error t value Pr(&gt;|t|)    
## b1  0.76886    0.01828   42.06 1.91e-06 ***
## b2  3.86041    0.05173   74.63 1.93e-07 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.03285 on 4 degrees of freedom
## 
## Number of iterations to convergence: 3 
## Achieved convergence tolerance: 5.447e-06</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test1</code></pre></div>
<pre><code>## $pfilename
## [1] &quot;DanielWood&quot;
## 
## $nstart
## [1] 0
## 
## $minmeth
## [1] &quot;nls&quot;
## 
## $submeth
## NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">readline</span>(<span class="st">&quot;continue&quot;</span>)</code></pre></div>
<pre><code>## continue</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test2 &lt;-<span class="st"> </span><span class="kw">runoptprob</span>(<span class="dt">pfilename=</span>pfname, <span class="dt">minmeth=</span><span class="st">&quot;nlxb&quot;</span>)</code></pre></div>
<pre><code>## list()
## list()
## 
## &gt; probname &lt;- &quot;DanielWood&quot;
## 
## &gt; probdesc &lt;- &quot;These data and model are described in Daniel and Wood (1980), and\noriginally published in E.S.Keeping, 'Introduction to Statistical In ...&quot; ... [TRUNCATED] 
## 
## &gt; DanielWood.setup &lt;- function() {
## +     y &lt;- c(2.138, 3.421, 3.597, 4.34, 4.882, 5.66)
## +     x &lt;- c(1.309, 1.471, 1.49, 1.565, 1.611, 1.68)
## +     Dan .... [TRUNCATED] 
## 
## &gt; DanielWood.f &lt;- function(x) {
## +     res &lt;- DanielWood.res(x)
## +     f &lt;- sum(res * res)
## + }
## 
## &gt; DanielWood.res &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     res &lt;- rep(NA, length(xx))
## +     b1 &lt;- b[1]
## +     b2 &lt; .... [TRUNCATED] 
## 
## &gt; DanielWood.jac &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     n &lt;- length(b)
## +     m &lt;- length(xx)
## +     b1 &lt;- b[1]
##  .... [TRUNCATED] 
## 
## &gt; DanielWood.h &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     H &lt;- t(JJ) %*% JJ
## +     res &lt;- DanielWood.res(x)
## + }
## 
## &gt; DanielWood.g &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     res &lt;- DanielWood.res(x)
## +     gg &lt;- as.vector(2 * t(JJ) %*% res)
## +     return(gg) .... [TRUNCATED] 
## 
## &gt; DanielWood.test &lt;- function() {
## + }
## Objects in workspace:
##  [1] &quot;control&quot;   &quot;mformula&quot;  &quot;minmeth&quot;   &quot;nstart&quot;    &quot;optecho&quot;  
##  [6] &quot;pfile&quot;     &quot;pfilename&quot; &quot;pfilepath&quot; &quot;runopts&quot;   &quot;starts&quot;   
## [11] &quot;submeth&quot;  
## pdat:
## $starts
##         b1 b2
## start1 1.0  5
## start2 0.7  4
## 
## $df
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## 
## $mformula
## y ~ b1 * x^b2
## &lt;environment: 0x33226a0&gt;
## 
## $probtype
## [1] &quot;nls&quot;
## 
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## nstart == 0 
##         b1 b2
## start1 1.0  5
## start2 0.7  4
## formula: y ~ b1 * x^b2
## &lt;environment: 0x33226a0&gt;
## lower:[1] -Inf -Inf
## upper:[1] Inf Inf
## $watch
## [1] FALSE
## 
## $phi
## [1] 1
## 
## $lamda
## [1] 1e-04
## 
## $offset
## [1] 100
## 
## $laminc
## [1] 10
## 
## $lamdec
## [1] 4
## 
## $femax
## [1] 10000
## 
## $jemax
## [1] 5000
## 
## $rofftest
## [1] TRUE
## 
## $smallsstest
## [1] TRUE
## 
## Data variable  y :[1] 2.138 3.421 3.597 4.340 4.882 5.660
## Data variable  x :[1] 1.309 1.471 1.490 1.565 1.611 1.680
## ssminval = 3.639473e-53 
## Start:lamda: 1e-04  SS= 149.7192  at  b1 = 1  b2 = 5  1 / 0
## roff = 0.08104665   converged =  FALSE 
## delta:        b1         b2 
## -0.2935688 -0.5437644 
## gjty:       [,1]
## b1 273.4627
## b2 127.6840
## gradient projection =  -149.7101  g-delta-angle= 143.3924 
## Stepsize= 1 
## &lt;&lt;lamda: 4e-05  SS= 4.617901  at  b1 = 0.7064312  b2 = 4.456236  2 / 1
## roff = 0.01403555   converged =  FALSE 
## delta:         b1          b2 
##  0.04300627 -0.50629468 
## gjty:       [,1]
## b1 36.84083
## b2 12.24312
## gradient projection =  -4.614241  g-delta-angle= 103.5277 
## Stepsize= 1 
## &lt;&lt;lamda: 1.6e-05  SS= 0.03204775  at  b1 = 0.7494375  b2 = 3.949941  3 / 2
## roff = 0.001038332   converged =  FALSE 
## delta:         b1          b2 
##  0.01910095 -0.08902608 
## gjty:        [,1]
## b1 2.1613197
## b2 0.7754481
## gradient projection =  -0.02775185  g-delta-angle= 97.62772 
## Stepsize= 1 
## &lt;&lt;lamda: 6.4e-06  SS= 0.00432114  at  b1 = 0.7685384  b2 = 3.860915  4 / 3
## roff = 1.280769e-05   converged =  FALSE 
## delta:           b1            b2 
##  0.0003250606 -0.0005128129 
## gjty:           [,1]
## b1 -0.025599344
## b2 -0.008753529
## gradient projection =  -3.832416e-06  g-delta-angle= 103.4919 
## Stepsize= 1 
## &lt;&lt;lamda: 2.56e-06  SS= 0.004317308  at  b1 = 0.7688635  b2 = 3.860402  5 / 4
## roff = 1.531446e-08   converged =  TRUE 
## delta:           b1            b2 
## -1.215752e-06  3.633677e-06 
## gjty:            [,1]
## b1 -9.960217e-06
## b2 -4.954001e-06
## gradient projection =  -5.892083e-12  g-delta-angle= 97.94562 
## Stepsize= 1 
## &lt;&lt;lamda: 1.024e-06  SS= 0.004317308  at  b1 = 0.7688623  b2 = 3.860406  6 / 5
## nlmrt class object: x 
## residual sumsquares =  0.0043173  on  6 observations
##     after  5    Jacobian and  6 function evaluations
##   name            coeff          SE       tstat      pval      gradient    JSingval   
## b1              0.768862       0.01828      42.06  1.911e-06    3.85e-10       14.05  
## b2               3.86041       0.05173      74.63  1.932e-07  -2.715e-10      0.5994  
## $resname
## [1] &quot;sol&quot;
## 
## $ssquares
## [1] 0.0043173
## 
## $nobs
## [1] 6
## 
## $coeff
##      b1      b2 
## 0.76886 3.86041 
## 
## $ct
## [1] &quot; &quot; &quot; &quot;
## 
## $mt
## [1] &quot; &quot; &quot; &quot;
## 
## $SEs
## [1] 0.018282 0.051727
## 
## $tstat
##     b1     b2 
## 42.056 74.631 
## 
## $pval
##         b1         b2 
## 1.9108e-06 1.9318e-07 
## 
## $Sd
## [1] 14.04921  0.59937
## 
## $gr
##           [,1]
## b1  3.8503e-10
## b2 -2.7148e-10
## 
## $jeval
## [1] 5
## 
## $feval
## [1] 6
## 
## formula: y ~ b1 * x^b2
## &lt;environment: 0x33226a0&gt;
## lower:[1] -Inf -Inf
## upper:[1] Inf Inf
## $watch
## [1] FALSE
## 
## $phi
## [1] 1
## 
## $lamda
## [1] 1e-04
## 
## $offset
## [1] 100
## 
## $laminc
## [1] 10
## 
## $lamdec
## [1] 4
## 
## $femax
## [1] 10000
## 
## $jemax
## [1] 5000
## 
## $rofftest
## [1] TRUE
## 
## $smallsstest
## [1] TRUE
## 
## Data variable  y :[1] 2.138 3.421 3.597 4.340 4.882 5.660
## Data variable  x :[1] 1.309 1.471 1.490 1.565 1.611 1.680
## ssminval = 2.5224e-56 
## Start:lamda: 1e-04  SS= 0.10376  at  b1 = 0.7  b2 = 4  1 / 0
## roff = 0.27419   converged =  FALSE 
## delta:      b1       b2 
##  0.06734 -0.14372 
## gjty:      [,1]
## b1 -4.2765
## b2 -1.3123
## gradient projection =  -0.099372  g-delta-angle= 98.046 
## Stepsize= 1 
## &lt;&lt;lamda: 4e-05  SS= 0.0058663  at  b1 = 0.76734  b2 = 3.8563  2 / 1
## roff = 0.035577   converged =  FALSE 
## delta:       b1        b2 
## 0.0015102 0.0041697 
## gjty:       [,1]
## b1 -0.51966
## b2 -0.18327
## gradient projection =  -0.001549  g-delta-angle= 129.34 
## Stepsize= 1 
## &lt;&lt;lamda: 1.6e-05  SS= 0.0043173  at  b1 = 0.76885  b2 = 3.8605  3 / 2
## roff = 5.0601e-05   converged =  FALSE 
## delta:         b1          b2 
##  1.2589e-05 -4.7982e-05 
## gjty:         [,1]
## b1 0.00074052
## b2 0.00027869
## gradient projection =  -4.0498e-09  g-delta-angle= 95.922 
## Stepsize= 1 
## &lt;&lt;lamda: 6.4e-06  SS= 0.0043173  at  b1 = 0.76886  b2 = 3.8604  4 / 3
## roff = 1.7412e-07   converged =  FALSE 
## delta:         b1          b2 
## -1.0563e-07  3.0249e-07 
## gjty:          [,1]
## b1 -5.1091e-08
## b2 -1.4000e-07
## gradient projection =  -3.6951e-14  g-delta-angle= 140.7 
## Stepsize= 1 
## &lt;&lt;lamda: 2.56e-06  SS= 0.0043173  at  b1 = 0.76886  b2 = 3.8604  5 / 4
## roff = 1.2461e-09   converged =  TRUE 
## delta:         b1          b2 
##  7.5754e-10 -2.1652e-09 
## gjty:         [,1]
## b1 1.1826e-10
## b2 9.1510e-10
## gradient projection =  -1.8918e-18  g-delta-angle= 153.35 
## Stepsize= 1 
## lamda: 2.56e-05  SS= 0.0043173  at  b1 = 0.76886  b2 = 3.8604  6 / 5
## nlmrt class object: x 
## residual sumsquares =  0.0043173  on  6 observations
##     after  5    Jacobian and  6 function evaluations
##   name            coeff          SE       tstat      pval      gradient    JSingval   
## b1              0.768862       0.01828      42.06  1.911e-06   1.183e-10       14.05  
## b2               3.86041       0.05173      74.63  1.932e-07   9.151e-10      0.5994  
## $resname
## [1] &quot;sol&quot;
## 
## $ssquares
## [1] 0.0043173
## 
## $nobs
## [1] 6
## 
## $coeff
##      b1      b2 
## 0.76886 3.86041 
## 
## $ct
## [1] &quot; &quot; &quot; &quot;
## 
## $mt
## [1] &quot; &quot; &quot; &quot;
## 
## $SEs
## [1] 0.018282 0.051727
## 
## $tstat
##     b1     b2 
## 42.056 74.631 
## 
## $pval
##         b1         b2 
## 1.9108e-06 1.9318e-07 
## 
## $Sd
## [1] 14.04923  0.59937
## 
## $gr
##          [,1]
## b1 1.1826e-10
## b2 9.1510e-10
## 
## $jeval
## [1] 5
## 
## $feval
## [1] 6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test2</code></pre></div>
<pre><code>## $pfilename
## [1] &quot;DanielWood&quot;
## 
## $nstart
## [1] 0
## 
## $minmeth
## [1] &quot;nlxb&quot;
## 
## $submeth
## NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">readline</span>(<span class="st">&quot;continue&quot;</span>)</code></pre></div>
<pre><code>## continue</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test3 &lt;-<span class="st"> </span><span class="kw">runoptprob</span>(<span class="dt">pfilename=</span>pfname, <span class="dt">minmeth=</span><span class="st">&quot;optimr&quot;</span>, <span class="dt">submeth=</span><span class="st">&quot;L-BFGS-B&quot;</span>)</code></pre></div>
<pre><code>## list()
## list()
## 
## &gt; probname &lt;- &quot;DanielWood&quot;
## 
## &gt; probdesc &lt;- &quot;These data and model are described in Daniel and Wood (1980), and\noriginally published in E.S.Keeping, 'Introduction to Statistical In ...&quot; ... [TRUNCATED] 
## 
## &gt; DanielWood.setup &lt;- function() {
## +     y &lt;- c(2.138, 3.421, 3.597, 4.34, 4.882, 5.66)
## +     x &lt;- c(1.309, 1.471, 1.49, 1.565, 1.611, 1.68)
## +     Dan .... [TRUNCATED] 
## 
## &gt; DanielWood.f &lt;- function(x) {
## +     res &lt;- DanielWood.res(x)
## +     f &lt;- sum(res * res)
## + }
## 
## &gt; DanielWood.res &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     res &lt;- rep(NA, length(xx))
## +     b1 &lt;- b[1]
## +     b2 &lt; .... [TRUNCATED] 
## 
## &gt; DanielWood.jac &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     n &lt;- length(b)
## +     m &lt;- length(xx)
## +     b1 &lt;- b[1]
##  .... [TRUNCATED] 
## 
## &gt; DanielWood.h &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     H &lt;- t(JJ) %*% JJ
## +     res &lt;- DanielWood.res(x)
## + }
## 
## &gt; DanielWood.g &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     res &lt;- DanielWood.res(x)
## +     gg &lt;- as.vector(2 * t(JJ) %*% res)
## +     return(gg) .... [TRUNCATED] 
## 
## &gt; DanielWood.test &lt;- function() {
## + }
## Objects in workspace:
##  [1] &quot;control&quot;   &quot;mformula&quot;  &quot;minmeth&quot;   &quot;nstart&quot;    &quot;optecho&quot;  
##  [6] &quot;pfile&quot;     &quot;pfilename&quot; &quot;pfilepath&quot; &quot;runopts&quot;   &quot;starts&quot;   
## [11] &quot;submeth&quot;  
## pdat:
## $starts
##         b1 b2
## start1 1.0  5
## start2 0.7  4
## 
## $df
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## 
## $mformula
## y ~ b1 * x^b2
## &lt;environment: 0x2669348&gt;
## 
## $probtype
## [1] &quot;nls&quot;
## 
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## nstart == 0 
##         b1 b2
## start1 1.0  5
## start2 0.7  4
## Unit parameter scaling
## optim method failure
## $convergence
## [1] 9999
## 
## $value
## [1] 8.9885e+307
## 
## $par
## [1] NA NA
## 
## $counts
## [1] NA NA
## 
## $message
## [1] &quot;optim method failure\n&quot;
## 
## Unit parameter scaling
## optim method failure
## $convergence
## [1] 9999
## 
## $value
## [1] 8.9885e+307
## 
## $par
## [1] NA NA
## 
## $counts
## [1] NA NA
## 
## $message
## [1] &quot;optim method failure\n&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test3</code></pre></div>
<pre><code>## $pfilename
## [1] &quot;DanielWood&quot;
## 
## $nstart
## [1] 0
## 
## $minmeth
## [1] &quot;optimr&quot;
## 
## $submeth
## [1] &quot;L-BFGS-B&quot;</code></pre>
</div>
<div id="appendix-a-use-of-a-data-frame" class="section level2">
<h2>Appendix A: Use of a data frame</h2>
<p>The following script shows that we can store problem materials, including functions, <strong>INSIDE</strong> an <strong>R</strong> data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(NISTO)
<span class="kw">ls</span>(package:NISTO)
NISTO::DanielWood.res
NISTO:::DanielWood.res
f1 &lt;-<span class="st"> </span>y ~<span class="st"> </span>(b1+x*(b2+x*(b3+b4*x))) /<span class="st"> </span>(<span class="dv">1</span>+x*(b5+x*(b6+x*b7)))
<span class="kw">str</span>(f1)
?NISTO
?DanielWood
<span class="kw">data</span>(DanielWood)
DanielWood
dwprob &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mform =</span> f1, <span class="dt">mdata=</span>DanielWood, <span class="dt">pname=</span><span class="st">&quot;DanielWood&quot;</span>, <span class="dt">ptype=</span><span class="st">&quot;nls&quot;</span>)
dwprob
<span class="kw">data</span>()
f2 &lt;-<span class="st"> </span>y ~<span class="st"> </span>b1 /<span class="st"> </span>(<span class="dv">1</span>+<span class="kw">exp</span>(b2-b3*x))
r2data &lt;-Ratkowsky2
r2data
r2prob &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mform =</span> f2, <span class="dt">mdata=</span>Ratkowsky2, <span class="dt">pname=</span><span class="st">&quot;Ratkowsky2&quot;</span>, <span class="dt">ptype=</span><span class="st">&quot;nls&quot;</span>)
r2prob
myprobs &lt;-<span class="st"> </span><span class="kw">rbind</span>(dwprob, r2prob)
myprobs
<span class="kw">str</span>(myprobs)
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(myprobs)
<span class="kw">str</span>(myprobs.d)
f3 &lt;-<span class="st"> </span>y ~<span class="st"> </span><span class="kw">exp</span>(-b1*x)/(b2+b3*x)
c1data &lt;-<span class="st"> </span>Chwirut1
c1name &lt;-<span class="st"> &quot;Chwirut1&quot;</span>
c1prob &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mform =</span> f3, <span class="dt">mdata=</span>Chwirut1, <span class="dt">pname=</span>c1name, <span class="dt">ptype=</span><span class="st">&quot;nls&quot;</span>)
myprobs.d[<span class="dv">3</span>,] &lt;-<span class="st"> </span>c1prob
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.dataframe</span>(<span class="kw">rbind</span>(myprobs.d, c1prob))
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">rbind</span>(myprobs.d, c1prob))
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">rbind</span>(myprobs, c1prob))
myprobs.d
<span class="kw">str</span>(myprobs.d)
myprobs.d[,<span class="dv">5</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>
<span class="kw">str</span>(myprobs.d)
<span class="kw">colnames</span>(myprobs.d[,<span class="dv">5</span>] &lt;-<span class="st"> &quot;resfn&quot;</span>)
<span class="kw">colnames</span>(myprobs.d[,<span class="dv">5</span>]) &lt;-<span class="st"> &quot;resfn&quot;</span>
<span class="kw">colnames</span>(myprobs.d)[<span class="dv">5</span>] &lt;-<span class="st"> &quot;resfn&quot;</span>
myprobs.d
DanielWood.res &lt;-<span class="st"> </span>function(b) {
   xx&lt;-DanielWood$x <span class="co"># case !!</span>
   yy&lt;-DanielWood$y
   res &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(xx))
   b1&lt;-b[<span class="dv">1</span>]
   b2&lt;-b[<span class="dv">2</span>]
   res&lt;-b1*(xx**b2) -<span class="st"> </span>yy
   <span class="kw">return</span>(res)
}
myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>] &lt;-<span class="st"> </span>DanielWood.res
myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>] &lt;-<span class="st"> </span><span class="kw">quote</span>(DanielWood.res)
dwreschr &lt;-<span class="st"> &quot;DanielWood.res &lt;- function(b) {;xx&lt;-DanielWood$x; yy&lt;-DanielWood$y; res &lt;- rep(NA, length(xx)); b1&lt;-b[1];  b2&lt;-b[2];   res&lt;-b1*(xx**b2) - yy;   return(res);}&quot;</span>
myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>] &lt;-<span class="st"> </span>dwreschr
<span class="kw">ls</span>()
rm DanielWood.res
<span class="kw">rm</span>( DanielWood.res)
ls
<span class="kw">ls</span>()
<span class="kw">source</span>(<span class="st">&quot;myprobs.d[1,5])</span>
<span class="st">&quot;</span>
)
<span class="kw">source</span>(<span class="st">&quot;myprobs.d[1,5]&quot;</span>)
<span class="kw">source</span>(<span class="dt">text=</span><span class="st">&quot;myprobs.d[1,5]&quot;</span>)
?source
<span class="kw">parse</span>(<span class="dt">text=</span>myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>])
<span class="kw">ls</span>()
<span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span>myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>]))
<span class="kw">ls</span>()
<span class="kw">savehistory</span>(<span class="st">&quot;NISTOx1.txt&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># NISTOx2.txt</span>
test &lt;-<span class="st"> &quot;</span>
<span class="st"># Chwirut1 - Jacobian</span>
<span class="st">Chwirut1.jac &lt;- function(b) {</span>
<span class="st">   xx&lt;-Chwirut1$x</span>
<span class="st">   yy&lt;-Chwirut1$y</span>
<span class="st">   n&lt;-length(b)</span>
<span class="st">   m&lt;-length(xx)</span>
<span class="st">   b1&lt;-b[1]</span>
<span class="st">   b2&lt;-b[2]</span>
<span class="st">   b3&lt;-b[3]</span>
<span class="st">   J&lt;-matrix(0,m,n) # define the size of the Jacobian</span>
<span class="st">   expr3 &lt;- exp(-b1 * xx)</span>
<span class="st">   expr5 &lt;- b2 + b3 * xx</span>
<span class="st">   expr7 &lt;- expr3 * xx</span>
<span class="st">   expr10 &lt;- expr5*expr5</span>
<span class="st">   value &lt;- expr3/expr5</span>
<span class="st">   J[,1] &lt;- -(expr7/expr5)</span>
<span class="st">   J[,2] &lt;- -(expr3/expr10)</span>
<span class="st">   J[,3] &lt;- -(expr7/expr10)</span>
<span class="st">   return(J)</span>
<span class="st">}</span>
<span class="st">&quot;</span>
ftest &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(test))
ftest &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span>test))
bstart &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)
<span class="kw">print</span>(<span class="kw">ftest</span>(bstart))
<span class="kw">savehistory</span>(<span class="st">&quot;NISTOx2.txt&quot;</span>)</code></pre></div>
<div id="refs" class="references">
<div id="ref-danwood1980">
<p>Daniel, C., and F. S. Wood. 1980. <em>Fitting Equations to Data: Computer Analysis of Multifactor Data, Second Edition</em>. Wiley.</p>
</div>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
