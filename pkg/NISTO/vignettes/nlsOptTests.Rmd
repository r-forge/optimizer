---
title: "A structure for building and running optimization and nonlinear least squares tests for **R**"
author: "John C. Nash and Paul Gilbert"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: nlsOptTests.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Abstract

This article discusses how tests for nonlinear equations, least squares or equations 
may be set up, executed and analyzed for **R**. This activity is sensitive to the 
manner in which the test functions are computed, the choice of starting values, and
the choice of measures of success. They may also be modified by changes in the solvers
for the problems in question. Indeed, it is always a concern that seemingly minor 
adjustments intended to improve such solvers may cause them to fail on particular problems
or starting values. Thus it is desirable to be able to 

- be able to quickly and easily run a specific test on all available solvers;

- be able to quickly and easily run all available tests on an updated or new solver;

- be able to report successes and failures in a manner that allows for rapid detection
of potential issues with solvers.

The last criterion requires that there be a way to save and access the results of test runs.
Because each test instance can generate quite a lot of data, and the combinatorial possibilities
of tests, solvers, and solver options such as choice of gradient approximation, saving test
information could demand considerable storage space and data management effort. We outline 
some possible approaches to the data management aspect of optimization testing.

#

## Motivation

http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml presents a number of nonlinear
regression (nonlinear least squares) problems that are more or less difficult to solve
numerically. Doug Bates prepared an **R** package `NISTnls` which adapted these problems
to **R** and tested them with the `nls()` function of which he was a major author.
There are a number of other test function collections (some referenced below), 
usually with overlap in their
coverage, for nonlinear equations, nonlinear least squares and function minimization.
In some cases, such tests include bounds constraints or fixed parameters. 

In 2009, I built the incomplete package `NISTopt` to allow the same problems as in `NISTnls`
to be approached as unconstrained function minimization problems. Similarly, the Google 
Summer of Code project OptimGUI by Yixuan Qiu in 2011 attempted to provide a point-and-click
interface to aid in building and running function minimization problems in **R**, and 
developed a structure for storing such problems in a consistent manner. This vignette
is an attempt to better document such ideas. It is especially concerned with how to 
**efficiently** add, modify, run and review tests of the **R** tools to solve such problems. 

Note that the test problems used are **NOT** always good illustrations of the tasks to 
which the various
function minimization tools should be applied by general **R** users. 
However, they do suggest limits of performance of these tools. 

We note that in **R** circles, function minimization
is often called "optimization", though that generally implies that there
are also constraints. 

## Approach

We want to avoid having to write specific code to run each test. 
The package **optimrx** (??citation) can call most of the function 
minimization tools in **R** and can be extended to include others, and the
functions within this package standardize the call to each of the minimization
solvers. Thus we can simplify the code to test such solvers, using only their 
method name within the calls to either `optimr()` or `opm()`. Furthermore, these
functions allow a consistent syntax for specifying analytic gradients (if available),
the built-in gradient approximation (if this is part of the solver), else one of 
several pre-defined gradient approximations callable in the **optextras** package.
At the time of writing, an effort is in process to try to similarly unify the 
nonlinear least squares tools for **R**, namely, the `nls()` function in the **stats**
package, and the tools in packages **nlmrt**, **minpack.lm** and **nls2** as well as some
new efforts. 

### Specification of problems

Code developed in the trial package **NISTopt** suggested that a given problem could be
specified by a particular name. Thus, the problem of @danwood1980, is called **DanielWood**.
If we wish to solve it using one of the nonlinear least squares solvers that use a 
syntax like that of `nls()`, then we need to provide a model formula and some data that
is consistent with this model formula. By naming the formula as `DanielWood.formula`, and
putting the data in a dataframe named `DanielWood.df`, we then need only a starting
vector of parameters to have a well-specified formula-based nonlinear least squares 
problem. Besides `nls()`, `nlxb()` from **nlmrt**, `nls2()` from **nls2** (CRAN version),
and `nls.lm` from **minpack.lm**.

Similarly, a function-based nonlinear least squares problem solvable by `nlfb()` from 
package **nlmrt** or `nlsLM` from **minpack.lm** can be specified by an **R** function
that computes the residual vector from a particular set of parameters. These functions
can also use a Jacobian function if it is available. At the time of writing, an approximate
Jacobian will be provided by these solvers if the provided argument is NULL. Work is 
in process to try to provide particular derivative approximations by a mechanism similar
to the one used in package **optimrx**. We can provide for use of such solvers by using
the name `DanielWood.res` for the residual function and `DanielWood.jac` for the Jacobian.

Finally, for function minimization, we can specify `DanielWood.f` for a general function
to be minimized, with the (optional) `DanielWood.g` for the gradient. 

Many optimization problems, including some test problems, need data other than the parameters.
This can be provided by `DanielWood.setup`. This function will, if required, create the
dataframe for nonlinear least squares solvers.

There are often several sets of starting parameters for given test problems, as well as
the possibility of generated pseudo-random vectors, especially for those problems which have
a variable number of parameters. These can be provided in a matrix called `starts` which has
named columns, since the nonlinear least squares solvers using a model formula require 
parameter names. When the problem has no model formula, we can and do provide parameter names
as `p1, p2, ..., pn`. (?? not done yet, but it is in opm() already) The specification of 
starting parameters will be part of the `.setup` function.


Note that the `.res` function can be used to specify nonlinear equations problems if the 
solution has all the residuals at zero. At the time of writing, we have not yet included
this possibility.



### Restrictions on the problems

We do not wish (at the moment) to 
include general optimization problems with general constraints.
In fact, we will limit our attention to at most bounds constrained nonlinear optimization and
nonlinear least squares problems. There are, however, a lot of 
these. By considering lower and
upper bounds that are equal, we can extend the constraints to fixed or **masked** parameters.

## A sample design

Building on the ideas of the above section, we create the example **problem file** 
`DanielWood.prb`. In this case, we provide all the elements above. Thus we have a
**set** of problems, all of which can be accessed through a single structure. Through 
some experiments, detailed in *Appendix A: Use of a data frame*, we found that one could,
if desired, store such problems in a data frame, but this seems overly complicated.
Our flat, plain text files, one per named problem, should suffice. 
Other structures are, of course, equally possible. However, we will experiment with the
current approach until we discover it cannot support our requirements. 

### The **DanielWood** problem

Let us implement, in **R**, a possible file for the 
problem of @danwood1980.

```{r cache=FALSE, echo=FALSE}
require(knitr)
# read chunk (does not run code)
read_chunk('../inst/extdata/DanielWood.prb')
```

```{r}
<<DanielWood.prb>>
```

## Tools for preparing and using problem files

### Access to files

In order to use problem files, we need a way to list them, display their content in
both summary and detail, and attempt to use them with various nonlinear least squares
and/or function minimization software.

#### Command line file lister and display tool

We need a tool that 

- sets the directory where problems are found

- lists the files

- allows one file to be selected

- displays information in a structured way (possibly according to some profile)

- allows the profile for display to be edited somehow

?? code here

#### GUI file lister and display tool

Likely tied into command line tool by allowing command line to be executed when
mouse or pointer clicks are executed. Check existing GUI tools to see what is 
possible.

?? code here

### Building problem files

#### Data frame or matrix to source vector

If problem files are to be self contained, we do not want to need to access external
files. The simplest way to present a variable to **R** is to input data as a simple
list and then name it. To prepare the problem file, we therefore want to be able to
get data into the local **R** environment and prepare the text for an assignment
statement that contains a source vector.

?? code

```{r, eval=FALSE}

# Use paste() to build the c(...) structure

```


## Running problems

`runoptprob` -- ?? how it should be used

- provide 

    -- filename (at least the root)

    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)

    -- choice of gradient function or approximation (gr= (gr, "grfwd", etc.)) ?? optional?

    -- controls -- as per the control list in programs

    -- other arguments ?? how to provide? dotargs as below?

    -- xdata or dotargs (how to specify might be interesting)
    
    -- timing control (e.g., microbenchmark or simple timing)

- read output control profile (initially just use sink())

- read the file and execute it (make sure it has **R** commands so we can
actually source() it)

- analyze the call to runprob and do the appropriate call

- format output and extract and store summaries

  -- this may be multilayerd and take a lot of work
  
  -- start with no formatting, and gradually add features
  
  -- need to save conditions
  
  -- make sure we have time/date stamp on all runs
  
Issues to address?? :
 - sink() will save information, but there is a cost in time and space
 - how to do ok/not or red/yellow/green nicely | Do we want on params and value?
 - dealing with multiple solutions -- linear combination defined
 - where to put setting of FUZZ, reporting of deviations
  

```{r cache=FALSE, echo=FALSE}
require(knitr)
# read chunk (does not run code)
read_chunk('../R/runoptprob.R')
```

```{r}
require(nlmrt, quietly=TRUE)
require(optimrx, quietly=TRUE)
<<runoptprob.R>>
```

## Running multiple problems

- prepare "problem list", like a play list

- run them in sequence

- try to figure out how to save the output 
    
    -- sink
    
    -- summaries
    
    -- test against expected output
    
    -- timings
    
    -- measures of success


For the moment, let us just call runoptprob(). Note that it creates a sinkfile for each
call.

```{r}
pfname <- "DanielWood"
# try it
test1 <- runoptprob(pfilename=pfname, minmeth="nls")
test1
tmp <- readline("continue")

test2 <- runoptprob(pfilename=pfname, minmeth="nlxb")
test2
tmp <- readline("continue")

test3 <- runoptprob(pfilename=pfname, minmeth="optimr", submeth="L-BFGS-B")
test3
```


## Appendix A: Use of a data frame

The following script shows that we can store problem materials, including functions,
**INSIDE** an **R** data frame.

```{r, eval=FALSE}
require(NISTO)
ls(package:NISTO)
NISTO::DanielWood.res
NISTO:::DanielWood.res
f1 <- y ~ (b1+x*(b2+x*(b3+b4*x))) / (1+x*(b5+x*(b6+x*b7)))
str(f1)
?NISTO
?DanielWood
data(DanielWood)
DanielWood
dwprob <- list(mform = f1, mdata=DanielWood, pname="DanielWood", ptype="nls")
dwprob
data()
f2 <- y ~ b1 / (1+exp(b2-b3*x))
r2data <-Ratkowsky2
r2data
r2prob <- list(mform = f2, mdata=Ratkowsky2, pname="Ratkowsky2", ptype="nls")
r2prob
myprobs <- rbind(dwprob, r2prob)
myprobs
str(myprobs)
myprobs.d <- as.data.frame(myprobs)
str(myprobs.d)
f3 <- y ~ exp(-b1*x)/(b2+b3*x)
c1data <- Chwirut1
c1name <- "Chwirut1"
c1prob <- list(mform = f3, mdata=Chwirut1, pname=c1name, ptype="nls")
myprobs.d[3,] <- c1prob
myprobs.d <- as.dataframe(rbind(myprobs.d, c1prob))
myprobs.d <- as.data.frame(rbind(myprobs.d, c1prob))
myprobs.d <- as.data.frame(rbind(myprobs, c1prob))
myprobs.d
str(myprobs.d)
myprobs.d[,5] <- NA
str(myprobs.d)
colnames(myprobs.d[,5] <- "resfn")
colnames(myprobs.d[,5]) <- "resfn"
colnames(myprobs.d)[5] <- "resfn"
myprobs.d
DanielWood.res <- function(b) {
   xx<-DanielWood$x # case !!
   yy<-DanielWood$y
   res <- rep(NA, length(xx))
   b1<-b[1]
   b2<-b[2]
   res<-b1*(xx**b2) - yy
   return(res)
}
myprobs.d[1,5] <- DanielWood.res
myprobs.d[1,5] <- quote(DanielWood.res)
dwreschr <- "DanielWood.res <- function(b) {;xx<-DanielWood$x; yy<-DanielWood$y; res <- rep(NA, length(xx)); b1<-b[1];  b2<-b[2];   res<-b1*(xx**b2) - yy;   return(res);}"
myprobs.d[1,5] <- dwreschr
ls()
rm DanielWood.res
rm( DanielWood.res)
ls
ls()
source("myprobs.d[1,5])
"
)
source("myprobs.d[1,5]")
source(text="myprobs.d[1,5]")
?source
parse(text=myprobs.d[1,5])
ls()
eval(parse(text=myprobs.d[1,5]))
ls()
savehistory("NISTOx1.txt")
```

```{r, eval=FALSE}
# NISTOx2.txt
test <- "
# Chwirut1 - Jacobian
Chwirut1.jac <- function(b) {
   xx<-Chwirut1$x
   yy<-Chwirut1$y
   n<-length(b)
   m<-length(xx)
   b1<-b[1]
   b2<-b[2]
   b3<-b[3]
   J<-matrix(0,m,n) # define the size of the Jacobian
   expr3 <- exp(-b1 * xx)
   expr5 <- b2 + b3 * xx
   expr7 <- expr3 * xx
   expr10 <- expr5*expr5
   value <- expr3/expr5
   J[,1] <- -(expr7/expr5)
   J[,2] <- -(expr3/expr10)
   J[,3] <- -(expr7/expr10)
   return(J)
}
"
ftest <- eval(parse(test))
ftest <- eval(parse(text=test))
bstart <- c(1,1,1)
print(ftest(bstart))
savehistory("NISTOx2.txt")
```