<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="John C. Nash, Greg Snow" />

<meta name="date" content="2016-11-29" />

<title>Animating geometric optimization: small polygons</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Animating geometric optimization: small polygons</h1>
<h4 class="author"><em>John C. Nash, Greg Snow</em></h4>
<h4 class="date"><em>2016-11-29</em></h4>



<div id="abstract" class="section level2">
<h2>Abstract</h2>
<p><strong>Roptanimation</strong> is an experimental R package to display the progress of geometric animations. A classic example is the <strong>largest small polygon</strong> where we aim to maximize the area of the polygon subject to the constraint that no two vertices are separated by more than one unit of distance. This article discusses the problem and how the animation is created, but only shows snapshots of the animation.</p>
</div>
<div id="todos" class="section level2">
<h2>TODOS</h2>
<ul>
<li>sort out what is going on with tkrplot – does not always work</li>
<li>try nloptr</li>
<li>try shiny for running the animation ??</li>
<li>Do we want to make VMPOLY files available??</li>
</ul>
</div>
<div id="background" class="section level2">
<h2>Background</h2>
<p>The <strong>The Largest Small Hexagon</strong> is the title of a paper by <span class="citation">Graham (1975)</span>. This did not introduce this problem, but served to bring it to wider attention. The problem statement asks for the vertices of a hexagon with maximal area such that no two vertices are more than 1 unit distant from each other. There is even a Wikipedia entry for this problem (<a href="https://en.wikipedia.org/wiki/Biggest_little_polygon" class="uri">https://en.wikipedia.org/wiki/Biggest_little_polygon</a>). The approximate area of the optimal hexagon 0.674981, while it is fairly easy to show that a regular hexagon of diameter 1 has area 6 times the area of an equilateral triangle of side 0.5, i.e., 6 * 0.5 * 0.5 * sin(pi/3) / 2 = 0.6495191 (approximately).</p>
<p>The interest in this article is that problems like this have a natural visual quality that can be used to interest a non-technical audience, especially if the progress of an optimizater can be animated. Note that there are many mathematical aspects of such problems that we ignore in our treatment. See <span class="citation">Audet, Hansen, and Messine (2007)</span>.</p>
<p>To provide a visual presentation of the optimization, Nash coded a display for the IBM PC family of MS DOS computers running GWBASIC. This code was then used to to illustrate constrained optimization using the tools in <span class="citation">J. C. Nash and Walker-Smith (1987)</span> (now available online at <a href="https://archive.org/details/ost-engineering-jnmws2004" class="uri">https://archive.org/details/ost-engineering-jnmws2004</a>). The actual files for the polygon problem are part of this <strong>Roptanimation</strong> package. ?? In May 2016, the discovery that these files could still execute, albeit clumsily, under Linux using DosBox or PCBasic raised the possibility of bringing them up to date. R was a logical choice for such an implementation, given that the authors and many others work with this software system.</p>
<p>There are other animations of optimization tools. Using Javascript, Ben Frederickson developed a very attractive demonstration of a selection of optimization algorithms. See <a href="http://www.benfrederickson.com/numerical-optimization/" class="uri">http://www.benfrederickson.com/numerical-optimization/</a>. Duncan Murdoch prepared a very nice illustration of the behaviour of a Nelder-Mead polytope minimization, the code for which can be found at <a href="https://github.com/florianhartig/LearningBayes/blob/master/CommentedCode/02-Samplers/Optimization/Duncan-Murdoch-Nelder-Mead-demonstration.R" class="uri">https://github.com/florianhartig/LearningBayes/blob/master/CommentedCode/02-Samplers/Optimization/Duncan-Murdoch-Nelder-Mead-demonstration.R</a>.</p>
</div>
<div id="parametrization-of-the-polygon" class="section level2">
<h2>Parametrization of the polygon</h2>
<p>For a polygon with <code>nv</code> vertices, we have <code>2*nv</code> cartesian (i.e., x, y) coordinates. However, use of cartesian coordinates as parameters for this problem leads to a very complicated specification, since 2 parameters can be set at a fixed value right away as defining an origin of the polygon. That is, we can arbitrarily fix vertex 1 at the <code>(0, 0)</code> or origin of our [2D] space. Moreover, we can put the second vertex at <code>(b[1], 0)</code> where <code>b</code> is a vector of <code>(2*nv - 3)</code> parameters. Changing to a representation that uses a radius from the origin for vertex <code>L</code> equal to <code>b[L-1]</code>, we could use the angle of this vertex from the positive x axis as a parameter. Call this angle <code>alpha[L]</code>. Clearly <code>alpha[1]</code> for vertex 2 is 0, so the 2nd vertex is still at <code>(b[1], 0)</code>. Note that there is no <code>b[0]</code>, which would be the distance of vertex 1 from itself.</p>
<p>We could put the alpha angles in the parameter vector as <code>b[L+lshift]</code> where <code>lshift = nv - 3</code>. Thus the first non-zero angle is for vertex 3 and is parameter <code>3 + nv - 3 = nv</code>. Check: there are <code>(nv - 1)</code> radius parameters, so the first angle parameter is in position <code>nv</code>.</p>
<p>There may be good implementations based on having parameters <code>b[nv] ... b[2*nv-3]</code> equal to the angles for vertices <code>3...nv</code> from the x axis, e.g., as in <span class="citation">Dolan, Moré, and Munson (2004)</span> and <span class="citation">Audet, Hansen, and Messine (2007)</span>. However, that then requires the angles to be monotonically increasing. By specifying instead that <code>b[L+lshift] = alpha[L-1] - alpha[L-2]</code> for <code>L=3 ... nv</code>, and noting that <code>alpha[1]=0</code> we automatically get the angles alpha monotonic by imposing a lower bound of 0 on the parameters <code>b</code>.</p>
<p>Note that the radii already cannot be negative (in fact, zero is a bad idea too), so a lower bound of 0 can be applied to all the parameters <code>b</code>. An upper bound of 1 clearly applies to the first <code>(nv - 1)</code> parameters. The other <code>(nv - 2)</code> parameters are angles in radians. If we are to have the polygon in the positive y half-space in cartesian coordinates, then pi is an obvious (and likely conservative) bound on these angles. In fact, <code>pi</code> is a bound on their sum.</p>
<p>We make no assertion that this is the only or best parametrization of this problem, and welcome suggestions for other ways to prepare the optimization.</p>
</div>
<div id="problem-setup" class="section level2">
<h2>Problem setup</h2>
<p>The above parametrization is implemented in the function <code>polysetup(nv, defsize)</code>, where <code>defsize</code> is the default “size” of a regular polygon for which initial parameters are established. Generally we will begin our optimization with a polygon for which the size is smaller than 1, and also commence with a regular polygon for convenience. This ensures that our initial polygon is feasible, and some optimization methods such as <code>nmkb</code> require that. Note that for drawing the polygon, it is useful to think of a vertex <code>L+1</code> which is at the same position as vertex 1.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polysetup &lt;-<span class="st"> </span>function(nv, <span class="dt">defsize=</span><span class="fl">0.98</span>){
<span class="co"># Function to set up animation of the &quot;largest small polygon&quot;</span>
<span class="co">#   problem. This attempts to find the polygon in nv vertices</span>
<span class="co">#   that has the largest area inside the polygon subject to</span>
<span class="co">#   the constraint that no two vertices are more than 1 unit</span>
<span class="co">#   distant from each other.</span>
<span class="co">#   Ref. Graham, &quot;The largest small hexagon&quot; </span>
<span class="co">#    (J. Combinatorial Theory (A), vol. 18, pp. 165-170, 1975)</span>

    nvmax &lt;-<span class="st"> </span><span class="dv">100</span> <span class="co"># Arbitrary limit -- change ??</span>

    if (nv &gt;<span class="st"> </span>nvmax) { <span class="kw">stop</span>(<span class="st">&quot;Too many vertices for polygon&quot;</span>) }

    mcon &lt;-<span class="st"> </span>(nv<span class="dv">-2</span>)*(nv<span class="dv">-1</span>)/<span class="dv">2</span> <span class="co"># Number of distance constraints</span>

    n &lt;-<span class="st"> </span><span class="dv">2</span>*nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># Number of parameters in the problem</span>

    <span class="co"># Thus we use a vector b[] of length n</span>
    <span class="co"># Note that we use RADIAL coordinates to simplify the</span>
    <span class="co"># optimization, but convert to cartesian to plot them</span>
    <span class="co"># First point is always at the origin (0,0) cartesian</span>
    <span class="co"># Second point is at (b[1],0) in both cartesian or polar</span>
    <span class="co"># where cartesian is (x, y) and radial is (radius, angle)</span>
    <span class="co"># Choice: angle in radians. ??</span>
    <span class="co"># There are 2*nv cartesian coordinate values</span>
    <span class="co"># i.e., (x, y) for nv point</span>
    <span class="co"># But first point is (0,0) and second has angle 0</span>
    <span class="co">#   since point 2 fixed onto x axis (angular coordinate 0).</span>
    <span class="co"># So b[1] ... b[nv-1] give radial coordinates of points 2:nv</span>
    <span class="co"># and b[nv] ... b[2*nv-3] give angle coordinates of points 3:nv</span>
    <span class="co"># ?? not needed LET L8=nv-3: REM so l+l8 indexes angles as l=3..nv</span>
    <span class="co"># Distances between points can be worked out by cosine rule for</span>
    <span class="co"># triangles i.e. D = sqrt(ra^2 + rb^2 - 2 ra rb cos(angle)</span>
    <span class="co"># Now set lower and upper bounds</span>

    lb &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n) <span class="co"># all angles and distances non-negative</span>

    ub &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>, (nv<span class="dv">-1</span>)), <span class="kw">rep</span>(pi, (nv<span class="dv">-2</span>))) <span class="co"># distances &lt;=1, angles &lt;= pi</span>

    <span class="co"># if we have angles &gt; pi, then we are reflecting the polygon about an edge</span>
    <span class="co"># set inital parameters to a regular polygon of size .98</span>
<span class="co">#    defsize &lt;- 0.98</span>
    regangle &lt;-<span class="st"> </span>pi/nv <span class="co">#  pi/(no. of vertices)</span>
<span class="co"># test to define polygon</span>
    q5 &lt;-<span class="st"> </span>defsize *<span class="st"> </span><span class="kw">sin</span>(regangle) <span class="co"># REM regangle/nv = alpha</span>
    b &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>,n)
<span class="co">#    x &lt;- rep(NA, nv)</span>
<span class="co">#    y &lt;- rep(NA, nv)</span>
<span class="co">#    x[1] &lt;- 0</span>
<span class="co">#    y[1] &lt;- 0</span>
<span class="co">#    x[2] &lt;- q5</span>
<span class="co">#    y[2] &lt;- 0</span>
    b[<span class="dv">1</span>] &lt;-<span class="st"> </span>q5
    q1 &lt;-<span class="st"> </span>q5
    q2 &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># x2 and y2</span>
    l8 &lt;-<span class="st"> </span>nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># offset for indexing</span>
    for (ll in <span class="dv">3</span>:nv){
        b[ll+l8] &lt;-<span class="st"> </span>regangle
        q1 &lt;-<span class="st"> </span>q1 +<span class="st"> </span>q5*<span class="kw">cos</span>(<span class="dv">2</span> *<span class="st"> </span>(ll<span class="dv">-2</span>) *<span class="st"> </span>regangle)
        q2 &lt;-<span class="st"> </span>q2 +<span class="st"> </span>q5 *<span class="st"> </span><span class="kw">sin</span>(<span class="dv">2</span> *<span class="st"> </span>(ll<span class="dv">-2</span>) *<span class="st"> </span>regangle)
<span class="co">#        x[ll]&lt;-q1</span>
<span class="co">#        y[ll]&lt;-q2</span>
        b[ll<span class="dv">-1</span>] &lt;-<span class="st"> </span><span class="kw">sqrt</span>(q1*q1 +<span class="st"> </span>q2*q2) <span class="co"># radius</span>
    }
    res &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">par0 =</span> b, <span class="dt">lb =</span> lb, <span class="dt">ub =</span> ub)
}</code></pre></div>
<p>The parameters of a regular hexagon of size 1 can be created as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A regular hexagon of size 1</span>
reghex1 &lt;-<span class="st"> </span><span class="kw">polysetup</span>(<span class="dv">6</span>, <span class="dt">defsize=</span><span class="dv">1</span>)
<span class="kw">cat</span>(<span class="st">&quot;Parameters of the regular hexagon of unit size</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Parameters of the regular hexagon of unit size</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(reghex1$par0)</code></pre></div>
<pre><code>## [1] 0.5000000 0.8660254 1.0000000 0.8660254 0.5000000 0.5235988 0.5235988
## [8] 0.5235988 0.5235988</code></pre>
</div>
<div id="the-polygon-area" class="section level2">
<h2>The polygon area</h2>
<p>The parameterization of the problem allows the area to be computed as the sum of the areas of the triangles made up from vertices <code>1</code>, <code>L</code> and <code>(L+1)</code> where <code>L</code> runs from <code>2</code> to <code>(nv-1)</code>. That is, there are <code>nv - 2</code> triangles. For the hexagon, the 4 triangles are made up of the vertices (1 2 3), (1 3 4), (1 4 5), and (1 5 6).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polyarea&lt;-function(b) {
   <span class="co"># compute area of a polygon defined by radial coordinates</span>
   <span class="co"># This IGNORES constraints</span>
   nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(b)+<span class="dv">3</span>)/<span class="dv">2</span>
   area &lt;-<span class="st"> </span><span class="dv">0</span> 
   l8 &lt;-<span class="st"> </span>nv<span class="dv">-3</span>
   for (l in <span class="dv">3</span>:nv){ <span class="co"># nv - 2 triangles</span>
      q1 &lt;-<span class="st"> </span>b[[l<span class="dv">-2</span>]] <span class="co"># side 1</span>
      q2 &lt;-<span class="st"> </span>b[[l<span class="dv">-1</span>]] <span class="co"># side 2</span>
      q3 &lt;-<span class="st"> </span>b[[l+l8]] <span class="co"># angle</span>
      atemp &lt;-<span class="st"> </span>q1*q2*<span class="kw">sin</span>(q3)
      area &lt;-<span class="st"> </span>area +<span class="st"> </span>atemp
   }
   area &lt;-<span class="st"> </span>area *<span class="st"> </span><span class="fl">0.5</span>
   area
}</code></pre></div>
<p>For reference, let us compute the area of this hexagon.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">reg1area &lt;-<span class="st"> </span><span class="kw">polyarea</span>(reghex1$par)
<span class="kw">cat</span>(<span class="st">&quot;Reference area of regular hexagon of unit size=&quot;</span>,reg1area,<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Reference area of regular hexagon of unit size= 0.6495191</code></pre>
<p>This is in accord with <span class="citation">Graham (1975)</span> and our result above.</p>
</div>
<div id="conversion-of-radial-to-cartesian-coordinates" class="section level2">
<h2>Conversion of radial to cartesian coordinates</h2>
<p>For drawing the current polygon, we need cartesian coordinates rather than the specially organized radial coordinates defined by the optimization parameters. The R function <code>polypar2XY</code> carries out this computation and puts the <code>x, y</code> coordinates in a two-vector list <code>XY</code>. <code>XY\$x</code> gives the <code>x</code> coordinates and <code>XY\$y</code> gives the <code>y</code> coordinates. To simplify the plotting of the polygon the first and last values of each list are both 0 so that a graph that uses lines to join the vertices automatically gives the closed figure polygon.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polypar2XY &lt;-<span class="st"> </span>function(b) {
<span class="co"># converts radial coordinates for polygon into Cartesian coordinates</span>
<span class="co">#  that are more suitable for plotting</span>
    nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(b)+<span class="dv">3</span>)/<span class="dv">2</span>
    l8 &lt;-<span class="st"> </span>nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># offset for indexing</span>
    x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, nv<span class="dv">+1</span>)
    y &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, nv<span class="dv">+1</span>)
    <span class="co"># One extra point to draw polygon (return to origin)</span>
    x[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
    y[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
    x[<span class="dv">2</span>] &lt;-<span class="st"> </span>b[<span class="dv">1</span>]
    y[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
    cumangle &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># Cumulative angle of points so far</span>
    q5 &lt;-<span class="st"> </span>b[<span class="dv">1</span>]
    q1 &lt;-<span class="st"> </span>q5 <span class="co"># x2</span>
    q2 &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co">#  y2</span>
    for (ll in <span class="dv">3</span>:nv){
        cumangle &lt;-<span class="st"> </span>cumangle +<span class="st"> </span>b[ll+l8]
        cradius &lt;-<span class="st"> </span>b[ll<span class="dv">-1</span>]
        q1 &lt;-<span class="st"> </span>cradius*<span class="kw">cos</span>(cumangle)
        q2 &lt;-<span class="st"> </span>cradius*<span class="kw">sin</span>(cumangle)
        x[ll]&lt;-q1
        y[ll]&lt;-q2
    }
    x[nv<span class="dv">+1</span>] &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># to close the polygon</span>
    y[nv<span class="dv">+1</span>] &lt;-<span class="st"> </span><span class="dv">0</span>    
    XY &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y)
    XY
}</code></pre></div>
</div>
<div id="distance-between-polygon-vertices" class="section level2">
<h2>Distance between polygon vertices</h2>
<p>To verify constraints and to construct penalty or barrier functions for the optimization process for this problem, we also need vertex to vertex distances. These are computed by the function <code>polydistXY</code>. This function uses the cartesian coordinates for the current polygon that result from running the function <code>polypar2XY</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polydistXY &lt;-<span class="st"> </span>function(XY) {
<span class="co">#   compute point to point distances from XY data</span>
   nv &lt;-<span class="st"> </span><span class="kw">length</span>(XY$x)-<span class="dv">1</span>
   ncon &lt;-<span class="st"> </span>(nv -<span class="st"> </span><span class="dv">1</span>)*(nv)/<span class="dv">2</span>
   dist2 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, ncon) <span class="co"># squared distances   </span>
   ll &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># index of constraint</span>
   for (i in <span class="dv">1</span>:(nv<span class="dv">-1</span>)){
      for (j in ((i<span class="dv">+1</span>):nv)){
         xi &lt;-<span class="st"> </span>XY$x[i]
         xj &lt;-<span class="st"> </span>XY$x[j]
         yi &lt;-<span class="st"> </span>XY$y[i]
         yj &lt;-<span class="st"> </span>XY$y[j]
         dd &lt;-<span class="st"> </span>(xi-xj)^<span class="dv">2</span> +<span class="st"> </span>(yi-yj)^<span class="dv">2</span>
         ll &lt;-<span class="st"> </span>ll +<span class="st"> </span><span class="dv">1</span>
         dist2[ll] &lt;-<span class="st"> </span>dd
      }
   }        
   dist2
}</code></pre></div>
</div>
<div id="computing-vertex-distances-from-radial-parameters" class="section level2">
<h2>Computing vertex distances from radial parameters</h2>
<p>We can compute these vertex distances from the radial parameters of the polygon by computing the XY coordinates and then the distances. The following function calls the conversion from radial to cartesian coordinates, then computes the distances.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polypar2distXY &lt;-<span class="st"> </span>function(pars) {
<span class="co"># compute the pairwise distances using two calls</span>
   nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(pars) +<span class="st"> </span><span class="dv">3</span>)/<span class="dv">2</span>
   XY &lt;-<span class="st"> </span><span class="kw">polypar2XY</span>(pars)
   dist2 &lt;-<span class="st"> </span><span class="kw">polydistXY</span>(XY)
}</code></pre></div>
<p>Alternatively, and perhaps more efficiently or at least more elegantly, we can do a one-step calculation. However, the following function ONLY computes the non-radial inter-vertex differences. The first <code>nv - 1</code> parameters where <code>nv</code> is the number of vertices give the other distances. Moreover, the positions of these distances in the output of polypar2distXY are not obvious at first glance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polypardist2 &lt;-<span class="st"> </span>function(b) {
<span class="co"># compute the pairwise distances for non-radii lines</span>
   nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(b) +<span class="st"> </span><span class="dv">3</span>)/<span class="dv">2</span> 
   l8 &lt;-<span class="st"> </span>nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># end of radii params</span>
   ll &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># count the distances (non-radii ones)</span>
   sqdist &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, (nv<span class="dv">-1</span>)*(nv<span class="dv">-2</span>)/<span class="dv">2</span>)
   for (ii in <span class="dv">2</span>:(nv<span class="dv">-1</span>)){
      for (jj in (ii<span class="dv">+1</span>):nv) {
          ra &lt;-<span class="st"> </span>b[ii<span class="dv">-1</span>]
          rb &lt;-<span class="st"> </span>b[jj<span class="dv">-1</span>]
          angleab &lt;-<span class="st"> </span><span class="dv">0</span>
          for (kk in (ii<span class="dv">+1</span>):jj) { angleab &lt;-<span class="st"> </span>angleab +<span class="st"> </span>b[kk+l8] }
          d2 &lt;-<span class="st"> </span>ra*ra+rb*rb -<span class="dv">2</span>*ra*rb*<span class="kw">cos</span>(angleab) <span class="co"># Cosine rule for squared dist</span>
          ll &lt;-<span class="st"> </span>ll<span class="dv">+1</span>
          sqdist[[ll]] &lt;-<span class="st"> </span>d2
      }
   }  
   sqdist
}</code></pre></div>
</div>
<div id="testing-functions." class="section level2">
<h2>Testing functions.</h2>
<p>Note that we tested our functions to create the original polygon and compute its area. This is a step that we recommend. In fact, one of us (JN) refuses to look at user queries about his optimization routines unless there is evidence that objective functions and gradients have been checked. It is an important part of the solution of EVERY optimization problem that users verify that they are solving the intended problem. Moreover, even in our own work, the simple checks often reveal silly but critical errors.</p>
<p>An example of a test script follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## @knitr polyex0

<span class="co"># Example code</span>
nv &lt;-<span class="st"> </span><span class="dv">6</span>
<span class="kw">cat</span>(<span class="st">&quot;Polygon data:</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Polygon data:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myhex &lt;-<span class="st"> </span><span class="kw">polysetup</span>(nv)
<span class="kw">print</span>(myhex)</code></pre></div>
<pre><code>## $par0
## [1] 0.4900000 0.8487049 0.9800000 0.8487049 0.4900000 0.5235988 0.5235988
## [8] 0.5235988 0.5235988
## 
## $lb
## [1] 0 0 0 0 0 0 0 0 0
## 
## $ub
## [1] 1.000000 1.000000 1.000000 1.000000 1.000000 3.141593 3.141593 3.141593
## [9] 3.141593</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x0 &lt;-<span class="st"> </span>myhex$par0 <span class="co"># initial parameters</span>
<span class="kw">cat</span>(<span class="st">&quot;Area:</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Area:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myhexa &lt;-<span class="st"> </span><span class="kw">polyarea</span>(x0)
<span class="kw">print</span>(myhexa)</code></pre></div>
<pre><code>## [1] 0.6237981</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;XY coordinates</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## XY coordinates</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myheXY &lt;-<span class="st"> </span><span class="kw">polypar2XY</span>(x0)
<span class="kw">print</span>(myheXY)</code></pre></div>
<pre><code>## $x
## [1]  0.000000e+00  4.900000e-01  7.350000e-01  4.900000e-01  5.196819e-17
## [6] -2.450000e-01  0.000000e+00
## 
## $y
## [1] 0.0000000 0.0000000 0.4243524 0.8487049 0.8487049 0.4243524 0.0000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(myheXY$x, myheXY$y, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><!-- --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Constraints:</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Constraints:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">myhexc&lt;-<span class="kw">polydistXY</span>(myheXY)
<span class="kw">print</span>(myhexc)</code></pre></div>
<pre><code>##  [1] 0.2401 0.7203 0.9604 0.7203 0.2401 0.2401 0.7203 0.9604 0.7203 0.2401
## [11] 0.7203 0.9604 0.2401 0.7203 0.2401</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Vertex distances:&quot;</span>)</code></pre></div>
<pre><code>## Vertex distances:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">sqrt</span>(myhexc))</code></pre></div>
<pre><code>##  [1] 0.4900000 0.8487049 0.9800000 0.8487049 0.4900000 0.4900000 0.8487049
##  [8] 0.9800000 0.8487049 0.4900000 0.8487049 0.9800000 0.4900000 0.8487049
## [15] 0.4900000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;check distances with polypar2distXY</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## check distances with polypar2distXY</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">try1 &lt;-<span class="st"> </span><span class="kw">polypar2distXY</span>(x0)
<span class="kw">print</span>(try1)</code></pre></div>
<pre><code>##  [1] 0.2401 0.7203 0.9604 0.7203 0.2401 0.2401 0.7203 0.9604 0.7203 0.2401
## [11] 0.7203 0.9604 0.2401 0.7203 0.2401</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;check distances with polypardist2 augmenting output with parameter squares</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## check distances with polypardist2 augmenting output with parameter squares</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">try2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x0)
try2 &lt;-<span class="st"> </span><span class="kw">c</span>(x0[<span class="dv">1</span>:(nv<span class="dv">-1</span>)]^<span class="dv">2</span>, try2)
<span class="kw">print</span>(try2)</code></pre></div>
<pre><code>##  [1] 0.2401 0.7203 0.9604 0.7203 0.2401 0.2401 0.7203 0.9604 0.7203 0.2401
## [11] 0.7203 0.9604 0.2401 0.7203 0.2401</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Max abs difference = &quot;</span>,<span class="kw">max</span>(<span class="kw">abs</span>(try1-try2)),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Max abs difference =  2.220446e-16</code></pre>
</div>
<div id="setup-of-the-optimization" class="section level2">
<h2>Setup of the optimization</h2>
<p>The constrained optimization to maximize the area actually minimizes the negative area. This is because most optimization solvers minimize, and we recommend keeping the direction of progress consistent to avoid errors.</p>
<p>We do, however, need to account for the constraints. Clearly since the radial parameters start at one vertex of the polygon, they are bounded above by 1. And naturally, we cannot have a polygon with negative lengths, so 0 is an obvious lower bound, though realistically, some modest positive value would likely be workable. This accounts for constraints on distance from the first, or base, vertex. For the other distances, we will apply a penalty function which will be added to the negative area. We can also put 0 as a lower bound on the angular parameters, and a reasonable upper bound as well. pi serves as a conservative bound for these parameters.</p>
<p>The solvers in the package <strong>optimrx</strong> represent the majority of the unconstrained and bounds constrained function minimizers commonly available in <strong>R</strong>. Typically, we create a penalty or barrier function that is added to our objective (the negative area) to impose the constraint. Penalty functions typically increase the objective more as we increasingly violate the constraints. Barrier functions start to add to the objective before the constraint boundary, increasing rapidly as we get very close to the boundary. We will use a number of these techniques. Our constrained objective functions are</p>
<ul>
<li><p>polyobjbig.R: the objective is assigned a very large value whenever a constraint is violated.</p></li>
<li><p>polyobjq.R: a multiple (<code>penfactor</code>) of the squared constraint violation is added to the negative area.</p></li>
<li><p>polyobj.R: a multiple (<code>penfactor</code>) of the negative sum of the logs of the <strong>slacks</strong> is added to the negative area. The slacks are the (positive) distances to the constraint boundaries. We must remain in the feasible region or this objective is undefined. We do not apply slacks to the radial coordinates in this objective function, for which we attempt solutions only with solvers that can handle bounds constraints.</p></li>
<li><p>polyobju.R: this is essentially the same objective function as polyobj.R, but we now compute slacks for the radial parameters, so that unconstrained minimizers can be applied to this function.</p></li>
</ul>
<p>Because the log() function increases extremely rapidly for small arguments, the <code>penfactor</code> for the barrier functions is generally quite small, while that for the quadratic penalty is quite large. We also allow for the slacks / violations to be modified by shifting the constraint boundary slightly using a quantity <code>epsilon</code>. This latter option has not been examined closely yet.</p>
<p>There are two specific adjustments to the codes above we can make:</p>
<ul>
<li><p>Except for polyobjbig.R, we can compute gradients and the code is given below.</p></li>
<li><p>It is not uncommon for minimizers to make steps into an infeasible region. An attempt to avoid a halt in the minimization process due to an error, we have recoded polyobj.R to polyobjp.R which attempts to provide a large number for the objective in such cases. The gradient, however, may not be computable, so we try to provide a warning rather than an error.</p></li>
</ul>
<p>Here are the codes.</p>
<div id="making-objective-very-large-on-constraint-violation" class="section level3">
<h3>Making objective very large on constraint violation</h3>
<p>This is an old “trick” in optimization of using a non-gradient direct search method that assigns the objective function its correct value when the parameters are feasible and a very large value when they are violated. We supply the value of <code>bignum</code> to the objective function via the call.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polyobjbig &lt;-<span class="st"> </span>function(x, <span class="dt">bignum=</span><span class="fl">1e10</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
 <span class="co"># Put objective to bignum when constraints violated</span>
 nv =<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span> <span class="co"># number of vertices</span>
 area &lt;-<span class="st"> </span><span class="kw">polyarea</span>(x)
 d2 &lt;-<span class="st"> </span><span class="kw">c</span>(x[<span class="dv">1</span>:(nv<span class="dv">-1</span>)]^<span class="dv">2</span>, <span class="kw">polypardist2</span>(x)) <span class="co"># distances</span>
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>d2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(d2 &gt;=<span class="dv">1</span>) ) { 
     f &lt;-<span class="st"> </span>bignum 
     <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>-area
 } else { 
    f &lt;-<span class="st">  </span>-area 
    <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>area
 } <span class="co"># negative area</span>
 <span class="kw">attr</span>(f,<span class="st">&quot;minslack&quot;</span>) &lt;-<span class="st"> </span><span class="kw">min</span>(slacks)
 f
}</code></pre></div>
<p>To test several optimizers at once, we use the <code>opm()</code> function of the R-forge package <code>optimrx</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## @knitr polyexbig

<span class="kw">library</span>(optimrx)
<span class="kw">cat</span>(<span class="st">&quot;Attempt with setting objective big on violation</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Attempt with setting objective big on violation</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x0 &lt;-<span class="st"> </span>myhex$par0 <span class="co"># starting parameters (slightly reduced regular hexagon)</span>
<span class="kw">cat</span>(<span class="st">&quot;Starting parameters:&quot;</span>)</code></pre></div>
<pre><code>## Starting parameters:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(x0)</code></pre></div>
<pre><code>## [1] 0.4900000 0.8487049 0.9800000 0.8487049 0.4900000 0.5235988 0.5235988
## [8] 0.5235988 0.5235988</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">meths &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Nelder-Mead&quot;</span>, <span class="st">&quot;nmkb&quot;</span>, <span class="st">&quot;hjkb&quot;</span>, <span class="st">&quot;newuoa&quot;</span>)
solb &lt;-<span class="st"> </span><span class="kw">opm</span>(x0, polyobjbig, <span class="dt">method=</span>meths, <span class="dt">bignum=</span><span class="fl">1e+10</span>)</code></pre></div>
<pre><code>## Warning in optimr(par, fn, gr, method = meth, lower = lower, upper =
## upper, : Successful convergence Restarts for stagnation =0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">summary</span>(solb, <span class="dt">order=</span>value, <span class="dt">par.select=</span><span class="dv">1</span>:<span class="dv">2</span>))</code></pre></div>
<pre><code>##                    p1        p2      value fevals gevals convergence  kkt1
## nmkb        0.4747329 0.7745629 -0.6634911   1025     NA           0 FALSE
## Nelder-Mead 0.5026671 0.8694462 -0.6495846   1396     NA           0 FALSE
## hjkb        0.4904883 0.8487049 -0.6492004    704     NA           0 FALSE
## newuoa      0.4961325 0.8482360 -0.6364518    151     NA           0 FALSE
##              kkt2 xtime
## nmkb        FALSE 0.165
## Nelder-Mead FALSE 0.145
## hjkb        FALSE 0.071
## newuoa      FALSE 0.016</code></pre>
<p>The two Nelder-Mead inspired codes are the best of a bad lot here, with Kelley’s variant (<code>nmkb</code>) doing a little better, though neither has got really close to the solution for the small hexagon problem. Note how different the solutions appear (we only include the first 2 parameters to save space). Let us draw them.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">NMpar &lt;-<span class="st"> </span><span class="kw">unlist</span>(solb[<span class="st">&quot;Nelder-Mead&quot;</span>,<span class="dv">1</span>:<span class="dv">9</span>])
nmkbpar &lt;-<span class="st"> </span><span class="kw">unlist</span>(solb[<span class="st">&quot;nmkb&quot;</span>,<span class="dv">1</span>:<span class="dv">9</span>])
<span class="kw">print</span>(NMpar)</code></pre></div>
<pre><code>##        p1        p2        p3        p4        p5        p6        p7 
## 0.5026671 0.8694462 1.0000000 0.8564697 0.4877712 0.5194433 0.5395326 
##        p8        p9 
## 0.5278314 0.5106744</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Nelder-Mead area=&quot;</span>, <span class="kw">polyarea</span>(NMpar))</code></pre></div>
<pre><code>## Nelder-Mead area= 0.6495846</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(nmkbpar)</code></pre></div>
<pre><code>##        p1        p2        p3        p4        p5        p6        p7 
## 0.4747329 0.7745629 0.9999993 0.9654443 0.6085645 0.4286187 0.3406976 
##        p8        p9 
## 0.6288541 0.6327525</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;nmkb area=&quot;</span>, <span class="kw">polyarea</span>(nmkbpar))</code></pre></div>
<pre><code>## nmkb area= 0.6634911</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">NMXY &lt;-<span class="st"> </span><span class="kw">polypar2XY</span>(NMpar)
nmkbXY &lt;-<span class="st"> </span><span class="kw">polypar2XY</span>(nmkbpar)
<span class="kw">plot</span>(NMXY$x, NMXY$y, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">xlim=</span><span class="kw">c</span>(-.<span class="dv">25</span>,<span class="fl">0.85</span>), <span class="dt">ylim=</span><span class="kw">c</span>(-.<span class="dv">05</span>, <span class="fl">1.05</span>), <span class="dt">xlab=</span><span class="st">&quot;x&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;y&quot;</span>)
<span class="kw">points</span>(nmkbXY$x, nmkbXY$y, <span class="dt">col=</span><span class="st">&quot;blue&quot;</span>, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>)
<span class="kw">title</span>(<span class="dt">main=</span><span class="st">&quot;Hexagons from NM (red) and nmkb (blue)&quot;</span>)</code></pre></div>
<p><img src="data:image/png;base64,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" alt /><!-- --></p>
<p>Caution: If the x and y scales of the plot surface are not equal, these drawings will not give a clear view of the results.</p>
<p>Drawing these polygons so we can visually compare them involves transformations that must align the polygons so one edge is on the x axis. But which edge to choose as the first? Then we must note that a vertical reflection of the polygon about the mid-point of the chosen edge will result in an equivalent solution. These options remind us that the optimization problem has multiple solutions, all with equal optimal area, which is part of the difficulty of the largest small polygon problem.</p>
</div>
<div id="quadratic-penalty-function" class="section level3">
<h3>Quadratic penalty function</h3>
<p>Our first try (which we will state in advance does not work well) is to add a multiple of the sum of the distance violations. These are the pairwise squared distances for those inter-vertex distances that are not given by the radial parameters. We assume the simple bounds are in force for the radial and angular parameters. This results in the following objective function with its associated gradient.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polyobjq &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="dv">0</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
 <span class="co"># negative area + penfactor*(sum(squared violations))</span>
 nv =<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span> <span class="co"># number of vertices</span>
 area  &lt;-<span class="st">  </span><span class="kw">polyarea</span>(x) <span class="co"># negative area</span>
 f &lt;-<span class="st"> </span>-area
 XY &lt;-<span class="st"> </span><span class="kw">polypar2XY</span>(x)
 dist2 &lt;-<span class="st"> </span><span class="kw">polydistXY</span>(XY)
 viol &lt;-<span class="st"> </span>dist2[<span class="kw">which</span>(dist2 &gt;<span class="st"> </span><span class="dv">1</span>)] -<span class="st"> </span><span class="fl">1.0</span>
 f &lt;-<span class="st"> </span>f +<span class="st"> </span>penfactor *<span class="st"> </span><span class="kw">sum</span>(viol)
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { 
    <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>-area
 } <span class="co"># in case of step into infeasible zone</span>
 else {  
    <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>area
 }
 <span class="kw">attr</span>(f,<span class="st">&quot;minslack&quot;</span>) &lt;-<span class="st"> </span><span class="kw">min</span>(slacks)
 f
}</code></pre></div>
<p>Setting the penalty factor (<code>penfactor</code>) at 100, we use M. J. Powell’s bobyqa minimizer to try to find the solution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start &lt;-<span class="st"> </span>myhex$par0 <span class="co"># starting parameters (slightly reduced regular hexagon)</span>
lb &lt;-<span class="st"> </span>myhex$lb
ub &lt;-<span class="st"> </span>myhex$ub
<span class="kw">cat</span>(<span class="st">&quot;Starting parameters:&quot;</span>)</code></pre></div>
<pre><code>## Starting parameters:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(start)</code></pre></div>
<pre><code>## [1] 0.4900000 0.8487049 0.9800000 0.8487049 0.4900000 0.5235988 0.5235988
## [8] 0.5235988 0.5235988</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(minqa)
<span class="kw">cat</span>(<span class="st">&quot;Attempt with quadratic penalty</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Attempt with quadratic penalty</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sol1 &lt;-<span class="st"> </span><span class="kw">bobyqa</span>(start, polyobjq, <span class="dt">lower=</span>lb, <span class="dt">upper=</span>ub, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">iprint=</span><span class="dv">2</span>), <span class="dt">penfactor=</span><span class="dv">100</span>)</code></pre></div>
<pre><code>## ctrl$force.start =  FALSE 
## npt = 11 , n =  9 
## rhobeg =  0.196 , rhoend =  1.96e-07 
## start par. =  0.49 0.8487049 0.98 0.8487049 0.49 0.5235988 0.5235988 0.5235988 0.5235988 fn =  -0.6237981 
## rho:    0.020 eval:  12 fn:    -0.598980 par:0.490000 0.804000  1.00000 0.804000 0.490000 0.523599 0.523599 0.523599 0.523599 
## rho:   0.0020 eval:  28 fn:    -0.619909 par:0.489342 0.824029  1.00000 0.801911 0.492375 0.544427 0.536770 0.533561 0.536283 
## rho:  0.00020 eval:  39 fn:    -0.620960 par:0.491029 0.822850 0.999660 0.803549 0.493529 0.544781 0.536990 0.535136 0.534761 
## rho:  2.0e-05 eval: 123 fn:    -0.640065 par:0.512451 0.833198  1.00000 0.798692 0.494576 0.559090 0.521389 0.569904 0.553712 
## rho:  2.0e-06 eval: 134 fn:    -0.640069 par:0.512438 0.833189  1.00000 0.798724 0.494587 0.559084 0.521398 0.569898 0.553685 
## rho:  2.0e-07 eval: 153 fn:    -0.640096 par:0.512442 0.833206 0.999998 0.798741 0.494597 0.559092 0.521412 0.569909 0.553691 
## At return
## eval: 222 fn:    -0.64010710 par: 0.512441 0.833218  1.00000 0.798738 0.494595 0.559108 0.521424 0.569917 0.553680</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(sol1)</code></pre></div>
<pre><code>## parameter estimates: 0.512441454563166, 0.83321811734493, 0.999999713433929, 0.798738098337695, 0.494595204899209, 0.559107505724644, 0.521423547340648, 0.569916736445338, 0.553680382296232 
## objective: -0.640107103929075 
## number of function evaluations: 222</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;area = &quot;</span>,<span class="kw">polyarea</span>(sol1$par),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## area =  0.6401071</code></pre>
<p>The objective is the negative area PLUS the penalty, so (-1) times this value is a lower bound on the area. But we see that it is smaller than the reference value (approximately 0.64952) of the unit regular hexagon. We also display the computed area directly, and it shows that the constraint penalty is not appreciably contributing to the objective. We clearly have more work to do.</p>
</div>
</div>
<div id="logarithmic-barrier-constraint" class="section level2">
<h2>Logarithmic barrier constraint</h2>
<p>A different kind of penalty is provided by the logarithmic barrier. This aims to keep the parameters feasible by adding a steeply increasing function to the objective (the negative area) as the constraint is approached. Let us first define the <strong>slack</strong> in a distance constraint as <code>slack = (1 - squared.distance)</code>. We could use the distance itself, but might as well avoid the extra computation. As each slack goes to zero, then <code>- log(slack)</code> goes to infinity. We can scale this, as in the quadratic penalty, with <code>penfactor</code>, but the actual numerical value will be much smaller now because <code>- log()</code> increases much more quickly than the quadratic.</p>
<p>There is an annoying computational practicality that some optimization methods may take steps in the parameter vector that push some distances into infeasible territory. This will cause exceptions to be generated when the logarithm of a negative “slack” is attempted. To avoid this, we will simply make the objective function very large at any time when there is a violation. However, this does cause grief for the evaluation of numerical approximations to gradients, so we may want to revise this policy later and seek more elegant (but likely more complicated) techniques to deal with this possibility. The large number for now will be <code>bignum = 1e20</code>. The code polyobjp.R attempts to avoid some of these difficulties, but there is still work to do.</p>
<p>Since the logarithmic barrier does not let the parameters end actually ON then bound, we may wish to move the constraint an epsilon beyond 1 by redefining the slack as</p>
<p><code>slack = (1 + epsilon - squared.distance)</code></p>
<p>But what should <code>epsilon</code> be? We may revisit this later, but for the moment set the value at 0, and the resulting code is as follows, with its associated gradient. And here is the gradient code. Note that we need to be careful about the indexing. We don’t show it here, but we did perform a quick check with package <code>numDeriv</code> that the gradient is correctly computed for the starting vector <code>x0</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polyobj &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="fl">1e-8</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
<span class="co"># log barrier objective function for small polygon</span>
<span class="co"># epsilon &lt;- 0</span>
 bignum &lt;-<span class="st"> </span><span class="fl">1e+20</span>
 <span class="co"># (negative area) + penfactor*(sum(squared violations))</span>
 nv =<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span> <span class="co"># number of vertices</span>
 area &lt;-<span class="st"> </span><span class="kw">polyarea</span>(x) <span class="co"># area</span>
 f &lt;-<span class="st"> </span>-<span class="st"> </span>area 
 dist2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x) <span class="co"># from radial coords, excluding radii (bounded)</span>
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { 
<span class="co">#     cat(&quot;polygrad: Infeasible parameters at\n&quot;)</span>
<span class="co">#     print(x)</span>
     f &lt;-<span class="st"> </span>bignum 
     area &lt;-<span class="st"> </span>-area <span class="co"># to code for infeasible and avoid plotting</span>
 } <span class="co"># in case of step into infeasible zone</span>
 else {  f &lt;-<span class="st"> </span>f -<span class="st"> </span>penfactor*<span class="kw">sum</span>(<span class="kw">log</span>(slacks)) }
 <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>area
 <span class="kw">attr</span>(f,<span class="st">&quot;minslack&quot;</span>) &lt;-<span class="st"> </span><span class="kw">min</span>(slacks)
 f
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polygrad &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="fl">1e-8</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
<span class="co"># log barrier gradient function for small polygon</span>
 nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span>
 l8 &lt;-<span class="st"> </span>nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># end of radii params</span>
<span class="co"># epsilon &lt;- 0</span>
 bignum &lt;-<span class="st"> </span><span class="fl">1e+20</span>
 <span class="co"># (negative area) + penfactor*(sum(squared violations))</span>
 nn &lt;-<span class="st"> </span><span class="kw">length</span>(x)
 gg &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, nn)
 dist2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x) <span class="co"># from radial coords, excluding radii (bounded)</span>
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { 
    <span class="kw">cat</span>(<span class="st">&quot;polygrad: Infeasible parameters at</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">print</span>(x)
    <span class="kw">stop</span>(<span class="st">&quot;polygrad: Infeasible&quot;</span>) 
 } 
 for (ll in <span class="dv">3</span>:nv) {
    ra&lt;-x[ll<span class="dv">-1</span>]
    rb&lt;-x[ll<span class="dv">-2</span>]
    abangle &lt;-<span class="st"> </span>x[l8 +<span class="st"> </span>ll]
    <span class="co"># are is 0.5*ra*rb*sin(abangle)</span>
    gg[ll<span class="dv">-2</span>] &lt;-<span class="st"> </span>gg[ll<span class="dv">-2</span>] -<span class="st"> </span><span class="fl">0.5</span>*ra*<span class="kw">sin</span>(abangle)
    gg[ll<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[ll<span class="dv">-1</span>] -<span class="st"> </span><span class="fl">0.5</span>*rb*<span class="kw">sin</span>(abangle)
    gg[ll+l8] &lt;-<span class="st"> </span>gg[ll+l8] -<span class="st"> </span><span class="fl">0.5</span>*ra*rb*<span class="kw">cos</span>(abangle)
 }
 ll &lt;-<span class="st"> </span><span class="dv">0</span>
 for (ii in <span class="dv">2</span>:(nv<span class="dv">-1</span>)){
    for (jj in (ii<span class="dv">+1</span>):nv) {
       ll &lt;-<span class="st"> </span>ll<span class="dv">+1</span>
       ra &lt;-<span class="st"> </span>x[ii<span class="dv">-1</span>]
       rb &lt;-<span class="st"> </span>x[jj<span class="dv">-1</span>]
       angleab &lt;-<span class="st"> </span><span class="dv">0</span>
       for (kk in (ii<span class="dv">+1</span>):jj) { angleab &lt;-<span class="st"> </span>angleab +<span class="st"> </span>x[kk+l8] }
       gg[ii<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[ii<span class="dv">-1</span>] +<span class="st"> </span><span class="dv">2</span>*penfactor*(ra-rb*<span class="kw">cos</span>(angleab))/slacks[ll]
       gg[jj<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[jj<span class="dv">-1</span>] +<span class="st"> </span><span class="dv">2</span>*penfactor*(rb-ra*<span class="kw">cos</span>(angleab))/slacks[ll]
       for (kk in (ii<span class="dv">+1</span>):jj){
          gg[kk+l8]&lt;-gg[kk+l8]+<span class="dv">2</span>*penfactor*ra*rb*<span class="kw">sin</span>(angleab)/slacks[ll]
       }
    }
 }
 gg
}</code></pre></div>
<p>To allow for unconstrained minimizers to act on this problem, we include the radial parameters in the logarithmic barriers, rather than use traditional active-set bounds. This results in the code polyobju.R.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polyobju &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="fl">1e-8</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
<span class="co"># polyobj with radial parameters constrained by log barrier</span>
<span class="co"># epsilon &lt;- 0</span>
 bignum &lt;-<span class="st"> </span><span class="fl">1e+20</span>
 <span class="co"># (negative area) + penfactor*(sum(squared violations))</span>
 nv =<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span> <span class="co"># number of vertices</span>
 area &lt;-<span class="st">  </span><span class="kw">polyarea</span>(x) 
 f &lt;-<span class="st"> </span>-area <span class="co"># negative area</span>
 dist2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x) <span class="co"># from radial coords, excluding radii (bounded)</span>
 dist2 &lt;-<span class="st"> </span><span class="kw">c</span>(x[<span class="dv">1</span>:(nv<span class="dv">-1</span>)]^<span class="dv">2</span>, dist2) <span class="co"># Add in radials. Note the squared distances used</span>
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { 
    f &lt;-<span class="st"> </span>bignum 
    <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>-area
 } <span class="co"># in case of step into infeasible zone</span>
 else {  
    f &lt;-<span class="st"> </span>f -<span class="st"> </span>penfactor*<span class="kw">sum</span>(<span class="kw">log</span>(slacks)) 
    <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>area
 }
 <span class="kw">attr</span>(f,<span class="st">&quot;minslack&quot;</span>) &lt;-<span class="st"> </span><span class="kw">min</span>(slacks)
<span class="co">#  pt1$add(x, -attr(f,&quot;minslack&quot;), attr(f, area), f)</span>
 f
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polygradu &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="fl">1e-8</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
 nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span>
 l8 &lt;-<span class="st"> </span>nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># end of radii params</span>
<span class="co"># epsilon &lt;- 0</span>
 <span class="co"># (negative area) + penfactor*(sum(squared violations))</span>
 nn &lt;-<span class="st"> </span><span class="kw">length</span>(x)
 gg &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, nn)
 dist2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x) <span class="co"># from radial coords, excluding radii (bounded)</span>
 dist2 &lt;-<span class="st"> </span><span class="kw">c</span>(x[<span class="dv">1</span>:(nv<span class="dv">-1</span>)]^<span class="dv">2</span>, dist2)
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>

 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { <span class="co"># Leave gradient at 0, rely on bignum in polyobju</span>
    <span class="kw">cat</span>(<span class="st">&quot;polygrad: Infeasible parameters at</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">print</span>(x)
     oldw &lt;-<span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;warn&quot;</span>)
     <span class="kw">options</span>(<span class="dt">warn =</span> -<span class="dv">1</span>)
     <span class="kw">warning</span>(<span class="st">&quot;Polygradu -- Infeasible&quot;</span>)  
     <span class="kw">options</span>(<span class="dt">warn =</span> oldw)
 } else { 
   for (ll in <span class="dv">3</span>:nv) {
     ra&lt;-x[ll<span class="dv">-1</span>]
     rb&lt;-x[ll<span class="dv">-2</span>]
     abangle &lt;-<span class="st"> </span>x[l8 +<span class="st"> </span>ll]
     <span class="co"># are is 0.5*ra*rb*sin(abangle)</span>
     gg[ll<span class="dv">-2</span>] &lt;-<span class="st"> </span>gg[ll<span class="dv">-2</span>] -<span class="st"> </span><span class="fl">0.5</span>*ra*<span class="kw">sin</span>(abangle)
     gg[ll<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[ll<span class="dv">-1</span>] -<span class="st"> </span><span class="fl">0.5</span>*rb*<span class="kw">sin</span>(abangle)
     gg[ll+l8] &lt;-<span class="st"> </span>gg[ll+l8] -<span class="st"> </span><span class="fl">0.5</span>*ra*rb*<span class="kw">cos</span>(abangle)
   }
 }
 ll &lt;-<span class="st"> </span><span class="dv">0</span>
 <span class="co"># components from radial parameter constraints (upper bounds)</span>
 for (ii in <span class="dv">1</span>:(nv<span class="dv">-1</span>)){
    ll &lt;-<span class="st"> </span>ll<span class="dv">+1</span>
    gg[ll] &lt;-<span class="st"> </span>gg[ll] +<span class="st"> </span><span class="dv">2</span>*penfactor*x[ll]/slacks[ll]
 }
 <span class="co"># components from other distances</span>
 for (ii in <span class="dv">2</span>:(nv<span class="dv">-1</span>)){
    for (jj in (ii<span class="dv">+1</span>):nv) {
       ll &lt;-<span class="st"> </span>ll<span class="dv">+1</span>
       ra &lt;-<span class="st"> </span>x[ii<span class="dv">-1</span>]
       rb &lt;-<span class="st"> </span>x[jj<span class="dv">-1</span>]
       angleab &lt;-<span class="st"> </span><span class="dv">0</span>
       for (kk in (ii<span class="dv">+1</span>):jj) { angleab &lt;-<span class="st"> </span>angleab +<span class="st"> </span>x[kk+l8] }
       gg[ii<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[ii<span class="dv">-1</span>] +<span class="st"> </span><span class="dv">2</span>*penfactor*(ra-rb*<span class="kw">cos</span>(angleab))/slacks[ll]
       gg[jj<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[jj<span class="dv">-1</span>] +<span class="st"> </span><span class="dv">2</span>*penfactor*(rb-ra*<span class="kw">cos</span>(angleab))/slacks[ll]
       for (kk in (ii<span class="dv">+1</span>):jj){
          gg[kk+l8]&lt;-gg[kk+l8]+<span class="dv">2</span>*penfactor*ra*rb*<span class="kw">sin</span>(angleab)/slacks[ll]
       }
    }
 }
 gg
}</code></pre></div>
<p>Finally, our first attempt to overcome non-computability when a step crosses the constraint boundary and the log barrier is inadmissible.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polyobjp &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="fl">1e-8</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
<span class="co"># log barrier objective function for small polygon</span>
<span class="co"># epsilon &lt;- 0</span>
 bignum &lt;-<span class="st"> </span><span class="fl">1e+20</span>
 <span class="co"># (negative area) + penfactor*(sum(squared violations))</span>
 nv =<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span> <span class="co"># number of vertices</span>
 <span class="kw">cat</span>(<span class="st">&quot;x:&quot;</span>)
 <span class="kw">print</span>(x)
 area &lt;-<span class="st"> </span><span class="kw">polyarea</span>(x) <span class="co"># area</span>
 f &lt;-<span class="st"> </span>-<span class="st"> </span>area 
 dist2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x) <span class="co"># from radial coords, excluding radii (bounded)</span>
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { 
     <span class="kw">cat</span>(<span class="st">&quot;polyobjp: Infeasible parameters at</span><span class="ch">\n</span><span class="st">&quot;</span>)
     <span class="kw">print</span>(x)
     f &lt;-<span class="st"> </span>bignum 
     area &lt;-<span class="st"> </span>-area <span class="co"># to code for infeasible and avoid plotting</span>
 } <span class="co"># in case of step into infeasible zone</span>
 else {  f &lt;-<span class="st"> </span>f -<span class="st"> </span>penfactor*<span class="kw">sum</span>(<span class="kw">log</span>(slacks)) }
 <span class="kw">attr</span>(f,<span class="st">&quot;area&quot;</span>) &lt;-<span class="st"> </span>area
 <span class="kw">attr</span>(f,<span class="st">&quot;minslack&quot;</span>) &lt;-<span class="st"> </span><span class="kw">min</span>(slacks)
 f
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">polygradp &lt;-<span class="st"> </span>function(x, <span class="dt">penfactor=</span><span class="fl">1e-8</span>, <span class="dt">epsilon=</span><span class="dv">0</span>) {
<span class="co"># log barrier gradient function for small polygon</span>
 nv &lt;-<span class="st"> </span>(<span class="kw">length</span>(x)+<span class="dv">3</span>)/<span class="dv">2</span>
 l8 &lt;-<span class="st"> </span>nv -<span class="st"> </span><span class="dv">3</span> <span class="co"># end of radii params</span>
<span class="co"># epsilon &lt;- 0</span>
 bignum &lt;-<span class="st"> </span><span class="fl">1e+20</span>
 <span class="co"># (negative area) + penfactor*(sum(squared violations))</span>
 nn &lt;-<span class="st"> </span><span class="kw">length</span>(x)
 gg &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, nn)
 dist2 &lt;-<span class="st"> </span><span class="kw">polypardist2</span>(x) <span class="co"># from radial coords, excluding radii (bounded)</span>
 slacks &lt;-<span class="st"> </span><span class="fl">1.0</span> +<span class="st"> </span>epsilon -<span class="st"> </span>dist2 <span class="co"># slack vector</span>
 if (<span class="kw">any</span>(slacks &lt;=<span class="st"> </span><span class="dv">0</span>)) { 
    <span class="kw">cat</span>(<span class="st">&quot;polygrad: Infeasible parameters at</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">print</span>(x)
    <span class="kw">warning</span>(<span class="st">&quot;polygrad: Infeasible&quot;</span>) 
    <span class="kw">return</span>(gg)
 } 
 for (ll in <span class="dv">3</span>:nv) {
    ra&lt;-x[ll<span class="dv">-1</span>]
    rb&lt;-x[ll<span class="dv">-2</span>]
    abangle &lt;-<span class="st"> </span>x[l8 +<span class="st"> </span>ll]
    <span class="co"># are is 0.5*ra*rb*sin(abangle)</span>
    gg[ll<span class="dv">-2</span>] &lt;-<span class="st"> </span>gg[ll<span class="dv">-2</span>] -<span class="st"> </span><span class="fl">0.5</span>*ra*<span class="kw">sin</span>(abangle)
    gg[ll<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[ll<span class="dv">-1</span>] -<span class="st"> </span><span class="fl">0.5</span>*rb*<span class="kw">sin</span>(abangle)
    gg[ll+l8] &lt;-<span class="st"> </span>gg[ll+l8] -<span class="st"> </span><span class="fl">0.5</span>*ra*rb*<span class="kw">cos</span>(abangle)
 }
 ll &lt;-<span class="st"> </span><span class="dv">0</span>
 for (ii in <span class="dv">2</span>:(nv<span class="dv">-1</span>)){
    for (jj in (ii<span class="dv">+1</span>):nv) {
       ll &lt;-<span class="st"> </span>ll<span class="dv">+1</span>
       ra &lt;-<span class="st"> </span>x[ii<span class="dv">-1</span>]
       rb &lt;-<span class="st"> </span>x[jj<span class="dv">-1</span>]
       angleab &lt;-<span class="st"> </span><span class="dv">0</span>
       for (kk in (ii<span class="dv">+1</span>):jj) { angleab &lt;-<span class="st"> </span>angleab +<span class="st"> </span>x[kk+l8] }
       gg[ii<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[ii<span class="dv">-1</span>] +<span class="st"> </span><span class="dv">2</span>*penfactor*(ra-rb*<span class="kw">cos</span>(angleab))/slacks[ll]
       gg[jj<span class="dv">-1</span>] &lt;-<span class="st"> </span>gg[jj<span class="dv">-1</span>] +<span class="st"> </span><span class="dv">2</span>*penfactor*(rb-ra*<span class="kw">cos</span>(angleab))/slacks[ll]
       for (kk in (ii<span class="dv">+1</span>):jj){
          gg[kk+l8]&lt;-gg[kk+l8]+<span class="dv">2</span>*penfactor*ra*rb*<span class="kw">sin</span>(angleab)/slacks[ll]
       }
    }
 }
 gg
}</code></pre></div>
<div id="running-the-log-barrier-constrained-functions" class="section level3">
<h3>Running the log barrier constrained functions</h3>
<p>With Powell’s bobyqa, we attempt to minimize this objective from the same start as before. We set the penalty factor quite small, in fact 0.01, as the barrier is non-zero within the feasible region.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## @knitr polyex2
<span class="kw">library</span>(minqa)
<span class="kw">cat</span>(<span class="st">&quot;Attempt with logarithmic barrier polyobj.R</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Attempt with logarithmic barrier polyobj.R</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x0 &lt;-<span class="st"> </span>myhex$par0 <span class="co"># starting parameters (slightly reduced regular hexagon)</span>
lb &lt;-<span class="st"> </span>myhex$lb
ub &lt;-<span class="st"> </span>myhex$ub
<span class="kw">cat</span>(<span class="st">&quot;Starting parameters:&quot;</span>)</code></pre></div>
<pre><code>## Starting parameters:</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(x0)</code></pre></div>
<pre><code>## [1] 0.4900000 0.8487049 0.9800000 0.8487049 0.4900000 0.5235988 0.5235988
## [8] 0.5235988 0.5235988</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sol2 &lt;-<span class="st"> </span><span class="kw">bobyqa</span>(x0, polyobj, <span class="dt">lower=</span>lb, <span class="dt">upper=</span>ub, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">iprint=</span><span class="dv">2</span>), <span class="dt">penfactor=</span><span class="fl">1e-3</span>)</code></pre></div>
<pre><code>## ctrl$force.start =  FALSE 
## npt = 11 , n =  9 
## rhobeg =  0.196 , rhoend =  1.96e-07 
## start par. =  0.49 0.8487049 0.98 0.8487049 0.49 0.5235988 0.5235988 0.5235988 0.5235988 fn =  -0.6111458 
## rho:    0.020 eval:  12 fn:    -0.588498 par:0.490000 0.804000  1.00000 0.804000 0.490000 0.523599 0.523599 0.523599 0.523599 
## rho:   0.0020 eval:  27 fn:    -0.604093 par:0.499975 0.846173  1.00000 0.823279 0.483358 0.516184 0.526795 0.518259 0.493750 
## rho:  0.00020 eval:  46 fn:    -0.625888 par:0.507189 0.860220  1.00000 0.836838 0.491940 0.521810 0.539439 0.531134 0.499982 
## rho:  2.0e-05 eval:  75 fn:    -0.629827 par:0.511862 0.864128  1.00000 0.840691 0.493209 0.524863 0.542018 0.534689 0.500412 
## rho:  2.0e-06 eval: 2387 fn:    -0.650552 par:0.639200  1.00000  1.00000 0.786610 0.554503 0.665309 0.560473 0.311998 0.411436 
## rho:  2.0e-07 eval: 3201 fn:    -0.650565 par:0.636984  1.00000  1.00000 0.792990 0.558537 0.664535 0.560359 0.305870 0.415645 
## At return
## eval: 3961 fn:    -0.65056501 par: 0.637031  1.00000  1.00000 0.793361 0.558558 0.664509 0.560293 0.305339 0.416229</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(sol2)</code></pre></div>
<pre><code>## parameter estimates: 0.637030820202343, 1, 1, 0.793360773838786, 0.558558288879639, 0.664508779656715, 0.560292618561939, 0.305338696990135, 0.416229413239744 
## objective: -0.650565009139302 
## number of function evaluations: 3961</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Area found=&quot;</span>,<span class="kw">polyarea</span>(sol2$par),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Area found= 0.670969</code></pre>
<p>This is not too bad. We can save the result then try with a smaller penalty factor.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x0a &lt;-<span class="st"> </span>sol2$par
sol2a &lt;-<span class="st"> </span><span class="kw">bobyqa</span>(x0a, polyobj, <span class="dt">lower=</span>lb, <span class="dt">upper=</span>ub, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">iprint=</span><span class="dv">2</span>), <span class="dt">penfactor=</span><span class="fl">1e-6</span>)</code></pre></div>
<pre><code>## ctrl$force.start =  FALSE 
## npt = 11 , n =  9 
## rhobeg =  0.2 , rhoend =  2e-07 
## start par. =  0.6370308 1 1 0.7933608 0.5585583 0.6645088 0.5602926 0.3053387 0.4162294 fn =  -0.6709485 
## rho:    0.020 eval:  12 fn:    -0.670949 par:0.637031  1.00000  1.00000 0.793361 0.558558 0.664509 0.560293 0.305339 0.416229 
## rho:   0.0020 eval:  15 fn:    -0.670949 par:0.637031  1.00000  1.00000 0.793361 0.558558 0.664509 0.560293 0.305339 0.416229 
## rho:  0.00020 eval:  32 fn:    -0.671863 par:0.638073  1.00000  1.00000 0.794591 0.559395 0.664587 0.560642 0.305090 0.416540 
## rho:  2.0e-05 eval:  45 fn:    -0.672442 par:0.638447  1.00000  1.00000 0.794616 0.559680 0.665070 0.561034 0.305482 0.416425 
## rho:  2.0e-06 eval:  64 fn:    -0.672567 par:0.638510  1.00000  1.00000 0.794669 0.559712 0.665121 0.561120 0.305559 0.416466 
## rho:  2.0e-07 eval: 103 fn:    -0.672676 par:0.638565  1.00000  1.00000 0.794721 0.559743 0.665162 0.561195 0.305630 0.416504 
## At return
## eval: 126 fn:    -0.67268438 par: 0.638570  1.00000  1.00000 0.794725 0.559746 0.665165 0.561202 0.305636 0.416508</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(sol2a)</code></pre></div>
<pre><code>## parameter estimates: 0.638570222992048, 1, 1, 0.794725053365082, 0.559745952614796, 0.665165198948008, 0.561201716067812, 0.305636373459819, 0.416507986873303 
## objective: -0.672684376780446 
## number of function evaluations: 126</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Area found=&quot;</span>,<span class="kw">polyarea</span>(sol2a$par),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Area found= 0.6727129</code></pre>
<p>And again, reducing the penfactor to 1e-9.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x0b &lt;-<span class="st"> </span>sol2a$par
sol2b &lt;-<span class="st"> </span><span class="kw">bobyqa</span>(x0b, polyobj, <span class="dt">lower=</span>lb, <span class="dt">upper=</span>ub, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">iprint=</span><span class="dv">2</span>), <span class="dt">penfactor=</span><span class="fl">1e-9</span>)</code></pre></div>
<pre><code>## ctrl$force.start =  FALSE 
## npt = 11 , n =  9 
## rhobeg =  0.2 , rhoend =  2e-07 
## start par. =  0.6385702 1 1 0.7947251 0.559746 0.6651652 0.5612017 0.3056364 0.416508 fn =  -0.6727129 
## rho:    0.020 eval:  12 fn:    -0.672713 par:0.638570  1.00000  1.00000 0.794725 0.559746 0.665165 0.561202 0.305636 0.416508 
## rho:   0.0020 eval:  15 fn:    -0.672713 par:0.638570  1.00000  1.00000 0.794725 0.559746 0.665165 0.561202 0.305636 0.416508 
## rho:  0.00020 eval:  32 fn:    -0.673085 par:0.638786  1.00000  1.00000 0.792886 0.560085 0.665504 0.562955 0.305975 0.415432 
## rho:  2.0e-05 eval:  44 fn:    -0.673250 par:0.638350 0.999975 0.999912 0.792655 0.560491 0.665975 0.563454 0.305807 0.415801 
## rho:  2.0e-06 eval:  55 fn:    -0.673251 par:0.638343 0.999977 0.999909 0.792672 0.560488 0.665980 0.563438 0.305818 0.415807 
## rho:  2.0e-07 eval:  74 fn:    -0.673324 par:0.638369  1.00000 0.999940 0.792693 0.560501 0.666001 0.563472 0.305849 0.415824 
## At return
## eval:  97 fn:    -0.67332988 par: 0.638371  1.00000 0.999943 0.792695 0.560503 0.666003 0.563475 0.305851 0.415825</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(sol2b)</code></pre></div>
<pre><code>## parameter estimates: 0.638371107806375, 0.999999986222725, 0.999942803383823, 0.792695070477583, 0.560502941610218, 0.666002953540982, 0.563475097631064, 0.305851454663661, 0.415824820460551 
## objective: -0.67332988391386 
## number of function evaluations: 97</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Area found=&quot;</span>,<span class="kw">polyarea</span>(sol2b$par),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Area found= 0.6733299</code></pre>
<p>But a further attempt does very poorly.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x0c &lt;-<span class="st"> </span>sol2b$par
sol2c &lt;-<span class="st"> </span><span class="kw">bobyqa</span>(x0c, polyobj, <span class="dt">lower=</span>lb, <span class="dt">upper=</span>ub, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">iprint=</span><span class="dv">2</span>), <span class="dt">penfactor=</span><span class="fl">1e-12</span>)</code></pre></div>
<pre><code>## ctrl$force.start =  FALSE 
## npt = 11 , n =  9 
## rhobeg =  0.2 , rhoend =  2e-07 
## start par. =  0.6383711 1 0.9999428 0.7926951 0.5605029 0.666003 0.5634751 0.3058515 0.4158248 fn =  -0.6733299 
## rho:    0.020 eval:  12 fn:    -0.596071 par:0.638371  1.00000 0.800000 0.792695 0.560503 0.666003 0.563475 0.305851 0.415825 
## rho:   0.0020 eval:  25 fn:    -0.596071 par:0.638371  1.00000 0.800000 0.792695 0.560503 0.666003 0.563475 0.305851 0.415825 
## rho:  0.00020 eval:  40 fn:    -0.596853 par:0.640432  1.00000 0.801867 0.791897 0.561442 0.662747 0.563765 0.306243 0.416146 
## rho:  2.0e-05 eval:  49 fn:    -0.596944 par:0.640496 0.999992 0.802040 0.791888 0.561429 0.662812 0.563664 0.306221 0.416323 
## rho:  2.0e-06 eval:  60 fn:    -0.596954 par:0.640475 0.999995 0.802041 0.791904 0.561479 0.662803 0.563601 0.306298 0.416339 
## rho:  2.0e-07 eval:  71 fn:    -0.596954 par:0.640474 0.999996 0.802041 0.791904 0.561479 0.662804 0.563600 0.306298 0.416338 
## At return
## eval:  87 fn:    -0.59695455 par: 0.640474 0.999996 0.802041 0.791904 0.561479 0.662804 0.563600 0.306298 0.416339</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(sol2c)</code></pre></div>
<pre><code>## parameter estimates: 0.640474391667351, 0.999996417062993, 0.802041283838145, 0.791903551091848, 0.561479278235947, 0.662803852361194, 0.563600339100899, 0.306298370757193, 0.416338505743423 
## objective: -0.596954550526281 
## number of function evaluations: 87</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&quot;Area found=&quot;</span>,<span class="kw">polyarea</span>(sol2c$par),<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</code></pre></div>
<pre><code>## Area found= 0.5969546</code></pre>
<p>Possibly another method could do better.</p>
<p>In polyobju.R, we adjust the objective so the radial parameters are constrained using a logarithmic barrier, then use an unconstrained optimization method. There are a number of unconstrained optimization methods, and the <code>optimrx</code> package lets us try them out all at once. To avoid too much computing time, we use three methods, all of which could use bounds if we provided them.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(optimrx)
methset &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Rvmmin&quot;</span>, <span class="st">&quot;L-BFGS-B&quot;</span>, <span class="st">&quot;nlminb&quot;</span>)
suall &lt;-<span class="st"> </span><span class="kw">opm</span>(x0, polyobju, polygradu, <span class="dt">method=</span>methset, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">trace=</span><span class="dv">0</span>, <span class="dt">kkt=</span><span class="ot">FALSE</span>), <span class="dt">penfactor=</span><span class="fl">1e-5</span>)</code></pre></div>
<pre><code>## Warning in Rvmminu(par = spar, fn = efn, gr = egr, control =
## mcontrol, ...): Too many gradient evaluations</code></pre>
<pre><code>## polygrad: Infeasible parameters at
## [1] 0.7181999 1.2439587 1.4363998 1.2439587 0.7181999 0.7172732 0.9109475
## [8] 0.9109475 0.7172732</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># NOTE: Got complex Hessian eigenvalues when trying for KKT tests</span>
suall &lt;-<span class="st"> </span><span class="kw">summary</span>(suall, <span class="dt">order=</span>value)
<span class="kw">print</span>(suall)</code></pre></div>
<pre><code>##                 p1        p2        p3        p4        p5        p6
## Rvmmin   0.3491730 0.7792452 0.9999709 0.7792452 0.3491731 0.6984394
## nlminb   0.2358899 0.6861468 0.9999352 0.9266884 0.5213950 0.4590175
## L-BFGS-B 0.4900000 0.8487049 0.9800000 0.8487049 0.4900000 0.5235988
##                 p7        p8        p9      value fevals gevals
## Rvmmin   0.6966009 0.6966013 0.6984390 -0.6743258    386   1501
## nlminb   0.6314811 0.6771101 0.6299766 -0.6704514    317    151
## L-BFGS-B 0.5235988 0.5235988 0.5235988 -0.6236083      3      3
##          convergence kkt1 kkt2 xtime
## Rvmmin             1   NA   NA 0.612
## nlminb             1   NA   NA 0.079
## L-BFGS-B           0   NA   NA 0.002</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">resu &lt;-<span class="st"> </span><span class="kw">coef</span>(suall)
nmeth &lt;-<span class="st"> </span><span class="kw">dim</span>(resu)[<span class="dv">1</span>]
best0 &lt;-<span class="st"> </span>resu[<span class="dv">1</span>,]
<span class="kw">polyarea</span>(best0)</code></pre></div>
<pre><code>## [1] 0.6749214</code></pre>
<p>This is quite good, and reasonably fast, though we note that the solver has terminated on too many gradients in the two best cases. Nevertheless, we have the area to 4 decimals. We can, of course, use the explicit bounds with these particular methods. Let us see how they perform.</p>
</div>
</div>
<div id="check-with-bounds" class="section level2">
<h2>Check with bounds</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sall &lt;-<span class="st">  </span><span class="kw">opm</span>(x0, polyobj, polygrad, <span class="dt">method=</span>methset, <span class="dt">lower=</span>lb, <span class="dt">upper=</span>ub, 
             <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">trace=</span><span class="dv">0</span>, <span class="dt">kkt=</span><span class="ot">FALSE</span>), <span class="dt">penfactor=</span><span class="fl">1e-5</span>)</code></pre></div>
<pre><code>## Warning in Rvmminb(par = spar, fn = efn, gr = egr, lower = slower, upper =
## supper, : Too many gradient evaluations</code></pre>
<pre><code>## polygrad: Infeasible parameters at
## [1] 0.7018826 1.0000000 1.0000000 1.0000000 0.7018826 0.7034137 0.8832286
## [8] 0.8832286 0.7034137</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sall &lt;-<span class="st"> </span><span class="kw">summary</span>(sall, <span class="dt">order=</span>value)
<span class="kw">print</span>(sall)</code></pre></div>
<pre><code>##                 p1        p2 p3        p4        p5        p6        p7
## Rvmmin   0.3271889 0.7594256  1 0.7934834 0.3773264 0.7038945 0.7021671
## nlminb   0.3998874 0.8245674  1 0.7444245 0.2969221 0.6926894 0.6762570
## L-BFGS-B        NA        NA NA        NA        NA        NA        NA
##                 p8        p9          value fevals gevals convergence kkt1
## Rvmmin   0.6964897 0.6842430  -6.743182e-01   7876   1501           1   NA
## nlminb   0.7026573 0.6850014  -6.733607e-01    339    151           1   NA
## L-BFGS-B        NA        NA  8.988466e+307     NA     NA        9999   NA
##          kkt2 xtime
## Rvmmin     NA 1.929
## nlminb     NA 0.078
## L-BFGS-B   NA 0.001</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">best1 &lt;-<span class="st"> </span><span class="kw">coef</span>(sall)[<span class="dv">1</span>,]
<span class="kw">polyarea</span>(best1)</code></pre></div>
<pre><code>## [1] 0.6747975</code></pre>
<p>Here, one of the methods – L-BFGS-B – has failed. Note that we did get a warning that the gradient was infeasible, and it is likely the method has stepped into the infeasible region. We also note that once again, the other two methods have hit gradient evaluation limits. Such limits are INSIDE the methods, though there are ways to set them. However, most users will not bother to learn how to do this (it is often quite obscure), and we believe that tests should be with stock versions of codes.</p>
<p>We note also that the best result is not quite so good as with the function polyobju.R.</p>
<div id="all-methods-available-to-optimrx" class="section level3">
<h3>All methods available to <strong>optimrx</strong></h3>
<p>We can use the function polyobju.R with all the methods available in the package <strong>optimrx</strong> from <a href="https://r-forge.r-project.org/projects/optimizer/" class="uri">https://r-forge.r-project.org/projects/optimizer/</a>. The results of running all the methods from <code>x0</code> where</p>
<pre><code>&gt; print(polyobju(x0, penfactor=1e-5))
[1] -0.6236083
attr(,&quot;area&quot;)
[1] 0.6237981
attr(,&quot;minslack&quot;)
[1] 0.0396</code></pre>
<p>are as follows (run on machine J6, 2016-11-29):</p>
<pre><code>p9      value fevals gevals convergence kkt1 kkt2 xtime
ucminf      0.1757560 -0.6743258    402    402           0   NA   NA 0.186
nlm         0.6984392 -0.6743258     NA    471           0   NA   NA 0.522
Rvmmin      0.6984390 -0.6743258    386   1501           1   NA   NA 0.563
Rcgmin      0.6984414 -0.6743258   3023   1501           1   NA   NA 0.819
BFGS        0.6979991 -0.6743241    342     83           0   NA   NA 0.062
Rtnmin      0.6987669 -0.6743190    630    630           2   NA   NA 1.128
hjkb        0.7062961 -0.6743079  11018     NA           0   NA   NA 1.135
nlminb      0.6299766 -0.6704514    317    151           1   NA   NA 0.077
CG          0.6202124 -0.6695781   4706   1501           1   NA   NA 0.915
nmkb        0.6513722 -0.6630782   1225     NA           0   NA   NA 0.205
hjn         0.3795476 -0.6607589  16223     NA           0   NA   NA 1.852
newuoa      0.5264272 -0.6507394  15000     NA           1   NA   NA 1.729
Nelder-Mead 0.5199981 -0.6496394   1502     NA           1   NA   NA 0.146
spg         0.5278788 -0.6491492   1816   1501           1   NA   NA 0.812
bobyqa      0.5383891 -0.6449078    409     NA           0   NA   NA 0.042
L-BFGS-B    0.5235988 -0.6236083      3      3           0   NA   NA 0.000
lbfgsb3     0.5235988 -0.6236083      3      3           0   NA   NA 0.004
lbfgs       0.5235988 -0.6236083     NA     NA       -1001   NA   NA 0.000</code></pre>
<p>We see that gradient methods occupy the top 6 positions, but also the lbfgs family of methods has not been able to proceed at all.</p>
</div>
</div>
<div id="issues-in-this-specification-and-minimization" class="section level2">
<h2>Issues in this specification and minimization</h2>
<p>The experiences above show that the minimization is sensitive to how we set up the problem and to the choice of the penalty factor. Some of the failures of methods with logarithmic barrier methods suggest that methods can easily step into infeasible territory. A private communication from Prof. S. G. Nash of George Mason University pointed out that the truncated Newton (and similarly the lbfgs family) methods need to employ a modified line search when the logarithmic barrier function is applied. See <span class="citation">S. G. Nash and Sofer (1993)</span>.</p>
<p>We have not (yet) investigated the use of a transfinite function approach to this problem? This transforms the range (a, b) into (-Inf, Inf) using an inverse hyperbolic tangent, thereby converting a bounds constrainted problem to an unconstrained one. This is, in fact, the method used by<code>nmkb()</code> from package dfOptim, though we have not applied that method here. The transformation can destabilize the optimization, and we still have to use a barrier or penalty function to handle the bounds that are not directly imposed on parameters.</p>
</div>
<div id="animating-the-progress-to-an-optimum" class="section level2">
<h2>Animating the progress to an optimum</h2>
<p>If we want to visualize the progress of our optimization, then we need to draw the polygons as the relevant parameter vectors are tried. However, we probably only want to draw the polygon when we have found a feasible one that increases the area. Furthermore, as we progress, it is helpful to indicate the rank of the polygons in order of area. This can be accomplished by “fading out” polygons that are already drawn, though that means keeping a record of at least some of the feasible, larger-area polygons.</p>
<p>We can achieve all these desiderata by means of the following function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(R6)
<span class="kw">library</span>(TeachingDemos)

 nvex &lt;-<span class="st"> </span><span class="dv">6</span> <span class="co"># default value -- need to check if we can change </span>

PolyTrack &lt;-<span class="st"> </span><span class="kw">R6Class</span>(<span class="st">&quot;PolyTrack&quot;</span>,
  <span class="dt">public =</span> <span class="kw">list</span>(
    <span class="dt">parms =</span> <span class="kw">list</span>(),
    <span class="dt">maxviol =</span> <span class="kw">list</span>(),
    <span class="dt">areas =</span> <span class="kw">list</span>(),
    <span class="dt">fvals =</span><span class="kw">list</span>(),
    <span class="dt">nv =</span> nvex,
    <span class="dt">PlotIt =</span> <span class="ot">TRUE</span>,
    <span class="dt">Delay =</span> <span class="fl">0.25</span>,
    <span class="dt">nPolys =</span> <span class="dv">5</span>,
    <span class="dt">add =</span> function(p,v,a, fval) { <span class="co"># add points of polygon and area</span>
      i &lt;-<span class="st"> </span><span class="kw">length</span>(self$parms) +<span class="st"> </span><span class="dv">1</span>
      self$parms[[i]] &lt;-<span class="st"> </span>p <span class="co"># the points</span>
      self$maxviol[[i]] &lt;-<span class="st"> </span>v <span class="co"># maximum violation</span>
      self$areas[[i]] &lt;-<span class="st"> </span>a <span class="co"># the area</span>
      self$fvals[[i]] &lt;-<span class="st"> </span>fval <span class="co"># objective</span>
      if(self$PlotIt) { <span class="co"># here PlotIt in environment is TRUE so we'll likely always do this</span>
        self$<span class="kw">PlotPolys</span>() <span class="co"># plot all polygons to date, then wait</span>
        <span class="kw">Sys.sleep</span>(self$Delay)
      }
      <span class="kw">return</span>(a)
    },
    <span class="dt">PlotPolys =</span> function(<span class="dt">i=</span>-<span class="dv">1</span>) { <span class="co"># to draw the polygons</span>
      if(i&lt;<span class="dv">0</span>) i &lt;-<span class="st"> </span><span class="kw">length</span>(self$parms)
      if(i==<span class="dv">0</span>) <span class="kw">return</span>()
      cols &lt;-<span class="st"> </span><span class="kw">hsv</span>(<span class="fl">0.6</span>, (<span class="dv">1</span>:self$nPolys)/self$nPolys, <span class="dv">1</span>)
      <span class="co"># sets up a vector of colours. In this case we want gradual fade-out</span>
      <span class="co"># of the older polygons so we can see the latest the best</span>
      start &lt;-<span class="st"> </span><span class="kw">pmax</span>(<span class="dv">1</span>, i-self$nPolys<span class="dv">+1</span>)
      plotParms &lt;-<span class="st"> </span>self$parms[<span class="kw">seq</span>(start,i)]
      n &lt;-<span class="st"> </span><span class="kw">length</span>(plotParms)
      if(n &lt;<span class="st"> </span>self$nPolys) cols &lt;-<span class="st"> </span><span class="kw">tail</span>(cols, n)
      coords &lt;-<span class="st"> </span><span class="kw">lapply</span>(plotParms, function(x) <span class="kw">polypar2XY</span>(x))
      <span class="kw">plot.new</span>()
      <span class="kw">plot.window</span>( <span class="dt">xlim=</span><span class="kw">do.call</span>(range, <span class="kw">lapply</span>(coords, function(xy) xy$x)),
                   <span class="dt">ylim=</span><span class="kw">do.call</span>(range, <span class="kw">lapply</span>(coords, function(xy) xy$y)),
                   <span class="dt">asp=</span><span class="dv">1</span>)
      for(ii in <span class="kw">seq_len</span>(n)) { <span class="co"># draw the edges of polygons in the set</span>
        <span class="kw">polygon</span>(coords[[ii]]$x, coords[[ii]]$y, <span class="dt">border=</span>cols[ii], <span class="dt">lwd=</span><span class="dv">3</span>)
      }
      <span class="co"># Here add display of area found</span>
      carea &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">unlist</span>(self$areas))
<span class="co">#      txt &lt;- paste(&quot;Max polygon area =&quot;,carea,&quot;  last=&quot;,unlist(self$areas)[-1])</span>
      txt &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;Max polygon area =&quot;</span>,carea)
      <span class="kw">title</span>(<span class="dt">main=</span>txt)
      <span class="kw">title</span>(<span class="dt">sub=</span><span class="kw">paste</span>(<span class="st">&quot;Max violation=&quot;</span>,self$maxviol[[i]],<span class="st">&quot;  obj.fn.=&quot;</span>,self$fvals[[i]]))
    }
  ) <span class="co"># end of public list, no private list</span>
<span class="co"># NOTE: Need to change nv to whatever is current value</span>
                     
)</code></pre></div>
<p>Calling the PolyTrack function creates a new environment to hold all the sets of points. Each time a new “better” polygon is found, the <code>nPolys</code> most recent (the code above uses 5) polygons are redrawn using the vector of (fading) colours.</p>
<pre><code> %%r drawpoly1, eval=FALSE%%</code></pre>
<p>As of Nov 10, 2016, replay of the stored points with <code>tkrplot</code> does not seem to work reliably.</p>
</div>
<div id="saved-results" class="section level2">
<h2>Saved results</h2>
<p>Because the code actually builds a list of the points where the polygon is “better”, we can play back the progress. There are tools in the <code>tkrplot</code> package that allow this to be made interactive. Thus, when the optimization terminates, we can redraw the polygons at will using the following code.</p>
</div>
<div id="acknowledgement" class="section level2">
<h2>Acknowledgement</h2>
<p>Email discussions with Prof. S. G. Nash of George Mason University have been helpful in developing some of the ideas in this article.</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-Audet2007">
<p>Audet, Charles, Pierre Hansen, and Frédéric Messine. 2007. “Extremal Problems for Convex Polygons.” <em>Journal of Global Optimization</em> 38 (2): 163–79. doi:<a href="https://doi.org/10.1007/s10898-006-9065-5">10.1007/s10898-006-9065-5</a>.</p>
</div>
<div id="ref-dolan2004benchmarking">
<p>Dolan, Elizabeth D. Dolan, Jorge J. Moré, and Todd S. Munson. 2004. “Benchmarking Optimization Software with COPS 3.0.” Technical memorandum ANL/MCS-TM-273. Argonne National Laboratory.</p>
</div>
<div id="ref-GRAHAM1975">
<p>Graham, R.L. 1975. “The Largest Small Hexagon.” <em>Journal of Combinatorial Theory, Series A</em> 18 (2): 165–70. doi:<a href="https://doi.org/http://dx.doi.org/10.1016/0097-3165(75)90004-7">http://dx.doi.org/10.1016/0097-3165(75)90004-7</a>.</p>
</div>
<div id="ref-jnmws87">
<p>Nash, John C., and Mary Walker-Smith. 1987. <em>Nonlinear Parameter Estimation: An Integrated System in BASIC</em>. Book. Marcel Dekker Inc.: New York.</p>
</div>
<div id="ref-NashSofer93">
<p>Nash, Stephen G., and Ariela Sofer. 1993. “A Barrier Method for Large-Scale Constrained Optimization.” <em>INFORMS (Formerly ORSA) Journal on Computing</em> 5 (1): 40–53.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
