print(fc03)
y<-as.array(y)
cat("test benbad() with y=as.array(1:10), x=c(1)\n")
fc04<-fnchk(x, benbad, trace=1, y)
print(fc04)
y<-"This is a string"
cat("test benbad() with y a string, x=c(1)\n")
fc05<-fnchk(x, benbad, trace=1, y)
print(fc05)
fr <- function(x) {   ## Rosenbrock Banana function
x1 <- x[1]
x2 <- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
xtrad<-c(-1.2,1)
ros1<-fnchk(xtrad, fr, trace=1)
print(ros1)
# tgrchk.R -- test gradient check for bad inputs or calls
rm(list=ls())
cat("Show how grchk works\n")
require(optimx)
jones<-function(xx){
x<-xx[1]
y<-xx[2]
ff<-sin(x*x/2 - y*y/4)*cos(2*x-exp(y))
ff<- -ff
}
jonesg <- function(xx) {
x<-xx[1]
y<-xx[2]
gx <-  cos(x * x/2 - y * y/4) * ((x + x)/2) * cos(2 * x - exp(y)) -
sin(x * x/2 - y * y/4) * (sin(2 * x - exp(y)) * 2)
gy <- sin(x * x/2 - y * y/4) * (sin(2 * x - exp(y)) * exp(y)) - cos(x *
x/2 - y * y/4) * ((y + y)/4) * cos(2 * x - exp(y))
gg <- - c(gx, gy)
}
xx <- c(1, 2)
gcans <- grchk(xx, jones, jonesg, trace=1, testtol=(.Machine$double.eps)^(1/3))
gcans
# tkktc.R -- test how kkt check works
rm(list=ls())
cat("Show how kktc works\n")
require(optimx)
sessionInfo()
jones<-function(xx){
x<-xx[1]
y<-xx[2]
ff<-sin(x*x/2 - y*y/4)*cos(2*x-exp(y))
ff<- -ff
}
jonesg <- function(xx) {
x<-xx[1]
y<-xx[2]
gx <-  cos(x * x/2 - y * y/4) * ((x + x)/2) * cos(2 * x - exp(y)) -
sin(x * x/2 - y * y/4) * (sin(2 * x - exp(y)) * 2)
gy <- sin(x * x/2 - y * y/4) * (sin(2 * x - exp(y)) * exp(y)) - cos(x *
x/2 - y * y/4) * ((y + y)/4) * cos(2 * x - exp(y))
gg <- - c(gx, gy)
}
xx<-0.5*c(pi,pi)
ans <- list() # set up structure
can call following if optimx present and updated
ans <- optimr(xx, jones, jonesg, method="Rvmmin")
ans
# can call following if optimx present and updated
ans <- optimr(xx, jones, jonesg, method="Rvmmin")
ans
ans$par <- c(3.154083, -3.689620)
kkans <- kktchk(ans$par, jones, jonesg)
kkans
# woodtest.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
#Example: Wood function
#
wood.f <- function(x){
res <- 100*(x[1]^2-x[2])^2+(1-x[1])^2+90*(x[3]^2-x[4])^2+(1-x[3])^2+
10.1*((1-x[2])^2+(1-x[4])^2)+19.8*(1-x[2])*(1-x[4])
return(res)
}
#gradient:
wood.g <- function(x){
g1 <- 400*x[1]^3-400*x[1]*x[2]+2*x[1]-2
g2 <- -200*x[1]^2+220.2*x[2]+19.8*x[4]-40
g3 <- 360*x[3]^3-360*x[3]*x[4]+2*x[3]-2
g4 <- -180*x[3]^2+200.2*x[4]+19.8*x[2]-40
return(c(g1,g2,g3,g4))
}
#hessian:
wood.h <- function(x){
h11 <- 1200*x[1]^2-400*x[2]+2;    h12 <- -400*x[1]; h13 <- h14 <- 0
h22 <- 220.2; h23 <- 0;    h24 <- 19.8
h33 <- 1080*x[3]^2-360*x[4]+2;    h34 <- -360*x[3]
h44 <- 200.2
H <- matrix(c(h11,h12,h13,h14,h12,h22,h23,h24,
h13,h23,h33,h34,h14,h24,h34,h44),ncol=4)
return(H)
}
wood.fgh <- function(x){
fval <- wood.f(x)
gval <- wood.g(x)
hval <- wood.h(x)
attr(fval,"gradient") <- gval
attr(fval,"hessian")<- hval
fval
}
#################################################
x0 <- c(-3,-1,-3,-1) # Wood standard start
cat("This FAILS to find minimum\n")
wd <- snewton(x0, fn=wood.f, gr=wood.g, hess=wood.h, control=list(trace=1))
print(wd)
cat("  with optimr\n")
wdo <- optimr(x0, fn=wood.f, gr=wood.g, hess=wood.h, method="snewton", control=list(trace=1))
print(wdo)
wd <- snewton(x0, fn=wood.f, gr=wood.g, hess=wood.h, control=list(trace=1))
print(wd)
cat("\n\n nlm() gives similar results\n")
t1nlm <- nlm(wood.fgh, x0, print.level=1)
print(t1nlm)
cat("\n\n nlm() gives similar results, but seems to use maxit iterations\n")
t1nlm <- nlm(wood.fgh, x0, print.level=1)
print(t1nlm)
## BUT ... it looks like nlminb is NOT using a true Newton-type method
t1nlminb <- nlminb(x0, wood.f, gradient=wood.g, hessian=wood.h, control=list(trace=1))
print(t1nlm)
## BUT ... it looks like nlminb is NOT using a true Newton-type method
t1nlminb <- nlminb(x0, wood.f, gradient=wood.g, hessian=wood.h, control=list(trace=1))
print(t1nlminb)
t1nlmo <- optimr(x0, wood.f, wood.g, hess=wood.h, method="nlm", control=list(trace=1))
print(t1nlmo)
## FOLLOWING SHOWS UP ERRORS??
t1nlminbo <- optimr(x0, wood.f, wood.g, hess=wood.h, method="nlminb", control=list(trace=1))
print(t1nlminb)
## FOLLOWING SHOWS UP ERRORS??
t1nlminbo <- optimr(x0, wood.f, wood.g, hess=wood.h, method="nlminb", control=list(trace=1))
# run1param.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
f1<-function(xx){ # function of one parameter
((3*xx+2)*xx-5)*xx+4  ## 3*xx^3 + 2*xx^2 -5*xx + 4
}
g1 <- function(xx){
gg <- 9*xx*xx+4*xx -5
}
x0 <- .1234
lb <- -1
ub <- 10
cat("R has optimize function for [1D] functions\n")
aoptimize <- optimize(f1, c(-1, 10))
print(aoptimize)
cat("or we can use optim() with method='Brent' \n")
abrent <- optim(x0, f1, lower=lb, upper=ub, method="Brent", control=list(trace=0))
print(abrent)
# My own Rvmmin and Rcgmin handle 1D
ansone2<-opm(x0, f1, g1, method = c("Rvmmin", "Rcgmin"), control=list(trace=0))
ansone2.sum<-summary(ansone, order=value)
ansone2.sum<-summary(ansone2, order=value)
print(ansone2.sum)
# maxfn.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
maxfn<-function(x) {
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {
f<-(-1)*maxfn(x)
return(f)
}
cat("test that maximize=TRUE works correctly\n")
n<-6
xx<-rep(1,n)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=0))
print(ansmax)
ansnegmax<-optimr(xx,negmaxfn, gr="grfwd",  method="Rvmmin", control=list(trace=0))
print(ansnegmax)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=0))
print(ansmax)
ansmaxn<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=0))
print(ansmax)
ansmaxn<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=0))
print(ansmaxn)
ansmaxn<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2))
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2))
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2, maxit=200))
fnscale <- -1
pscale <- 1
eefn <- function(spar, ...) {
# rely on pscale being defined in this enclosing environment
par <- spar*pscale
val <- maxfn(par, ...) * fnscale
}
ansmax<-optimr(xx, eefn, gr="grfwd", method="Rvmmin", control=list(trace=2))
print(ansmax)
amaxkkt <- kktchk(ansmax$par, maxfn, gr="grfwd", hess=NULL,  maximize=TRUE, control=list(trace=0))
amaxee <- kktchk(ansmax$par, maxfn, gr="grfwd", hess=NULL,  maximize=TRUE, control=list(trace=0))
print(amaxee)
eefn <- function(spar, ...) {
# rely on pscale being defined in this enclosing environment
par <- spar*pscale
val <- maxfn(par, ...) * fnscale
}
amaxee <- kktchk(ansmax$par, maxfn, gr="grfwd", hess=NULL,  maximize=TRUE, control=list(trace=0))
amaxee <- kktchk(ansmax$par, maxfn, gr="grfwd", hess=NULL,  maximize=TRUE, control=list(trace=2))
ansmax<-optimr(xx, eefn, gr="grfwd", method="Rvmmin", control=list(trace=2))
ansmax<-optimr(xx, eefn, gr="grfwd", method="Rvmmin", control=list(trace=2))
print(ansmax)
maxfun(rep(1,6))
ansmaxee<-optimr(xx, eefn, gr="grfwd", method="Rvmmin", control=list(trace=2))
print(ansmaxee)
ls()
maxfn(par=1:6)
maxfn(1:6)
xx
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=0))
print(ansmax)
ansmaxf<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=0))
print(ansmaxf)
# maxfn.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
maxfn<-function(x) {
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {
f<-(-1)*maxfn(x)
return(f)
}
cat("test that maximize=TRUE works correctly\n")
n<-6
xx<-rep(1,n)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=0))
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
# maxfn.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
maxfn<-function(x) {
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {
f<-(-1)*maxfn(x)
return(f)
}
cat("test that maximize=TRUE works correctly\n")
n<-6
xx<-rep(1,n)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
# maxfn.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
maxfn<-function(x) {
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {
f<-(-1)*maxfn(x)
return(f)
}
cat("test that maximize=TRUE works correctly\n")
n<-6
xx<-rep(1,n)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
# maxfn.R
##  author: John C. Nash
rm(list=ls())
require(optimx)
sessionInfo()
maxfn<-function(x) {
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {
f<-(-1)*maxfn(x)
return(f)
}
cat("test that maximize=TRUE works correctly\n")
n<-6
xx<-rep(1,n)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
print(ansmax)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2, maxit=200))
print(ansmax)
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2, maxit=2000))
print(ansmax)
ansmaxn<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2))
print(ansmaxn)
ansmaxn<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=FALSE, trace=2))
# THIS SHOULD FAIL
print(ansmaxn)
ansmaxboth<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE, fnscale=-1.0, trace=2))
print(ansmaxboth)
# 160706 -- not set up to maximize, except through optimr perhaps
n<-6
xx<-rep(1,n)
ansmax<-try(hjn(xx,maxfn, control=list(maximize=TRUE,trace=1, maxit=10, maxfeval=2000)))
print(ansmax)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
?subplex
subplex(xx, maxfn, control=list(maximize=TRUE))
library(subplex)
subplex(xx, maxfn, control=list(maximize=TRUE))
subplex(xx, maxfn)
subplex(xx, negmaxfn)
maxfn(1:6)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
ansmaxnmgood<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=FALSE,trace=2))
print(ansmaxnmgood)
ansmaxnmgood<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=FALSE,
fnscale=-1, trace=2))
print(ansmaxnmgood)
source("~/current/20211013optimx-variable-clash/optimx/tests/maxfn.R", echo=TRUE)
maxall
summary(maxall)
?hjn
ahjn<-hjn(xx, maxfn, control=list(trace=1))
ahjn
ahjn<-hjn(xx, negmaxfn, control=list(trace=1))
ahjn
ahjno<-optimr(xx, maxfn, control=list(trace=1, maximize=TRUE))
ahjno
source("~/current/20211013optimx-variable-clash/optimx/tests/maxfn.R", echo=TRUE)
summary(maxall, order=value)
# maxfn.R
##  author: John C. Nash
rm(list=ls())
cat("maxfn.R -- test that maximize=TRUE works correctly\n")
require(optimx)
sessionInfo()
maxfn<-function(x) {# fn to be MAXIMIZED
# max = 10 at 1:6
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {# explicit negative of maxfn
f<-(-1)*maxfn(x)
return(f)
}
n<-4
xx<-rep(1,n) # start at all 1s
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
print(ansmax) # should work OK
# specifying both maximize and fnscale gives maximize precedence with no message
ansmaxboth<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE, fnscale=-1.0, trace=2))
print(ansmaxboth)
cat("using the negmax function should give same parameters\n")
ansnegmax<-optimr(xx,negmaxfn, gr="grfwd",  method="Rvmmin", control=list(trace=0))
print(ansnegmax)# function value should be -10 however
ansmaxnm<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2, maxit=2000))
print(ansmaxnm)# try with Nelder-Mead
ansmaxnmbad<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2))
# THIS SHOULD FAIL UNBOUNDED
print(ansmaxnmbad)
# control$maximize takes precedence over control$fnscale=-1.
ansmaxnmgood<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=FALSE,
fnscale=-1, trace=2))
print(ansmaxnmgood)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
cl <- ctrldefault()
cl <- ctrldefault(4)
cl
cl$allmeth
tm<-cl$allmeth
tm[-"snewton"]
tm[-which(tm=="snewton")]
tm[-which("snewton" %in% tm)]
# maxfn.R
##  author: John C. Nash
rm(list=ls())
cat("maxfn.R -- test that maximize=TRUE works correctly\n")
require(optimx)
sessionInfo()
maxfn<-function(x) {# fn to be MAXIMIZED
# max = 10 at 1:6
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {# explicit negative of maxfn
f<-(-1)*maxfn(x)
return(f)
}
n<-4
xx<-rep(1,n) # start at all 1s
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
print(ansmax) # should work OK
# specifying both maximize and fnscale gives maximize precedence with no message
ansmaxboth<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE, fnscale=-1.0, trace=2))
print(ansmaxboth)
cat("using the negmax function should give same parameters\n")
ansnegmax<-optimr(xx,negmaxfn, gr="grfwd",  method="Rvmmin", control=list(trace=0))
print(ansnegmax)# function value should be -10 however
ansmaxnm<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2, maxit=2000))
print(ansmaxnm)# try with Nelder-Mead
ansmaxnmbad<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2))
# THIS SHOULD FAIL UNBOUNDED
print(ansmaxnmbad)
# control$maximize takes precedence over control$fnscale=-1.
ansmaxnmgood<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=FALSE,
fnscale=-1, trace=2))
print(ansmaxnmgood)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
tm <- ctrldefault(4)$allmeth
("snewton" %in% tm)
("snewtonm" %in% tm)
("snewt" %in% tm)
source("~/current/20211013optimx-variable-clash/optimx/tests/maxfn.R", echo=TRUE)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
n<-4
xx<-rep(1,n) # start at all 1s
ansmax<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE,trace=2))
print(ansmax) # should work OK
# specifying both maximize and fnscale gives maximize precedence with no message
ansmaxboth<-optimr(xx,maxfn, gr="grfwd", method="Rvmmin", control=list(maximize=TRUE, fnscale=-1.0, trace=2))
print(ansmaxboth)
cat("using the negmax function should give same parameters\n")
ansnegmax<-optimr(xx,negmaxfn, gr="grfwd",  method="Rvmmin", control=list(trace=0))
print(ansnegmax)# function value should be -10 however
ansmaxnm<-optimr(xx,maxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2, maxit=2000))
print(ansmaxnm)# try with Nelder-Mead
ansmaxnmbad<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=TRUE,trace=2))
# THIS SHOULD FAIL UNBOUNDED
print(ansmaxnmbad)
# control$maximize takes precedence over control$fnscale=-1.
ansmaxnmgood<-optimr(xx,negmaxfn, gr="grfwd", method="Nelder-Mead", control=list(maximize=FALSE,
fnscale=-1, trace=2))
print(ansmaxnmgood)
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
# maxfn.R
##  author: John C. Nash
rm(list=ls())
cat("maxfn.R -- test that maximize=TRUE works correctly\n")
require(optimx)
sessionInfo()
maxfn<-function(x) {# fn to be MAXIMIZED
# max = 10 at 1:6
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {# explicit negative of maxfn
f<-(-1)*maxfn(x)
return(f)
}
n<-4
xx<-rep(1,n) # start at all 1s
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
# maxfn.R
##  author: John C. Nash
rm(list=ls())
cat("maxfn.R -- test that maximize=TRUE works correctly\n")
require(optimx)
sessionInfo()
maxfn<-function(x) {# fn to be MAXIMIZED
# max = 10 at 1:6
n<-length(x)
ss<-seq(1,n)
f<-10-(crossprod(x-ss))^2
f<-as.numeric(f)
return(f)
}
negmaxfn<-function(x) {# explicit negative of maxfn
f<-(-1)*maxfn(x)
return(f)
}
n<-4
xx<-rep(1,n) # start at all 1s
maxall <- opm(xx, maxfn, gr="grfwd", method="ALL", control=list(maximize=TRUE))
summary(maxall, order=value)
