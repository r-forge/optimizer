
R version 3.1.1 Patched (2014-08-15 r66390) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: i386-w64-mingw32/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(nls14)
> 
> # Various derivatives 
> 
> fnDeriv(quote(1 + x + y), c("x", "y"))
{
    .value <- 1 + x + y
    .grad <- array(0, c(length(.value), 2L), list(NULL, c("x", 
    "y")))
    .grad[, "x"] <- 1
    .grad[, "y"] <- 1
    attr(.value, "gradient") <- .grad
    .value
}
> 
> Deriv(log(x), "x")
1/x
> Deriv(log(x, base=3), "x" )
1/(x * 1.09861228866811)
> 
> Deriv(exp(x), "x")
exp(x)
> Deriv(sin(x), "x")
cos(x)
> Deriv(cos(x), "x")
-sin(x)
> Deriv(tan(x), "x")
1/cos(x)^2
> Deriv(sinh(x), "x")
cosh(x)
> Deriv(cosh(x), "x")
sinh(x)
> Deriv(sqrt(x), "x")
0.5/sqrt(x)
> Deriv(pnorm(q), "q")
dnorm(q)
> Deriv(dnorm(x, mean), "mean")
dnorm(x - mean) * (x - mean)
> Deriv(asin(x), "x")
1/sqrt(1 + x^2)
> Deriv(acos(x), "x")
-1/sqrt(1 + x^2)
> Deriv(atan(x), "x")
1/(1 + x^2)
> Deriv(gamma(x), "x")
gamma(x) * digamma(x)
> Deriv(lgamma(x), "x")
digamma(x)
> Deriv(digamma(x), "x")
trigamma(x)
> Deriv(trigamma(x), "x")
psigamma(x, 2L)
> Deriv(psigamma(x, deriv = 5), "x")
psigamma(x, 6)
> Deriv(x*y, "x")
y
> Deriv(x/y, "x")
1/y
> Deriv(x^y, "x")
y * x^(y - 1)
> Deriv((x), "x")
[1] 1
> Deriv(+x, "x")
[1] 1
> Deriv(-x, "x")
[1] -1
> Deriv(abs(x), "x")
sign(x)
> Deriv(sign(x), "x")
[1] 0
> 
> # Various simplifications
> 
> Simplify(quote(+(a+b)))
a + b
> Simplify(quote(-5))
[1] -5
> Simplify(quote(--(a+b)))
a + b
> 
> Simplify(quote(exp(log(a+b))))
a + b
> Simplify(quote(exp(1)))
[1] 2.718282
> 
> Simplify(quote(log(exp(a+b))))
a + b
> Simplify(quote(log(1)))
[1] 0
> 
> Simplify(quote(!TRUE))
[1] FALSE
> Simplify(quote(!FALSE))
[1] TRUE
> 
> Simplify(quote((a+b)))
a + b
> 
> Simplify(quote(a + b + 0))
a + b
> Simplify(quote(0 + a + b))
a + b
> Simplify(quote((a+b) + (a+b)))
2 * (a + b)
> Simplify(quote(1 + 4))
[1] 5
> 
> Simplify(quote(a + b - 0))
a + b
> Simplify(quote(0 - a - b))
-a - b
> Simplify(quote((a+b) - (a+b)))
[1] 0
> Simplify(quote(5 - 3))
[1] 2
> 
> Simplify(quote(0*(a+b)))
[1] 0
> Simplify(quote((a+b)*0))
[1] 0
> Simplify(quote(1L * (a+b)))
a + b
> Simplify(quote((a+b) * 1))
a + b
> Simplify(quote((-1)*(a+b)))
-(a + b)
> Simplify(quote((a+b)*(-1)))
-(a + b)
> Simplify(quote(2*5))
[1] 10
> 
> Simplify(quote((a+b) / 1))
a + b
> Simplify(quote((a+b) / (-1)))
-(a + b)
> Simplify(quote(0/(a+b)))
[1] 0
> Simplify(quote(1/3))
[1] 0.3333333
> 
> Simplify(quote((a+b) ^ 1))
a + b
> Simplify(quote(2^10))
[1] 1024
> 
> Simplify(quote(log(exp(a), 3)))
a/1.09861228866811
> 
> Simplify(quote(FALSE && b))
[1] FALSE
> Simplify(quote(a && TRUE))
a
> Simplify(quote(TRUE && b))
b
> 
> Simplify(quote(a || TRUE))
[1] TRUE
> Simplify(quote(FALSE || b))
b
> Simplify(quote(a || FALSE))
a
> 
> Simplify(quote(if (TRUE) a+b))
a + b
> Simplify(quote(if (FALSE) a+b))
NULL
> 
> Simplify(quote(if (TRUE) a+b else a*b))
a + b
> Simplify(quote(if (FALSE) a+b else a*b))
a * b
> Simplify(quote(if (cond) a+b else a+b))
a + b
> 
> # This one was wrong...
> Simplify(quote(--(a+b)))
a + b
> 
> 
> proc.time()
   user  system elapsed 
   0.23    0.00    0.23 
