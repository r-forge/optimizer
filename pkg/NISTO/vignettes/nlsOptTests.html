<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="John C. Nash" />

<meta name="date" content="2016-11-10" />

<title>A structure for building optimization and nonlinear least squares tests for R</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">A structure for building optimization and nonlinear least squares tests for <strong>R</strong></h1>
<h4 class="author"><em>John C. Nash</em></h4>
<h4 class="date"><em>2016-11-10</em></h4>



<p>Note: This is now in a project with GIT/SVN support. 161031.</p>
<div id="motivation" class="section level1">
<h1>Motivation</h1>
<p><a href="http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml" class="uri">http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml</a> presents a number of nonlinear regression (nonlinear least squares) problems that are more or less difficult to solve numerically. Doug Bates prepared an <strong>R</strong> package <code>NISTnls</code> which adapted these problems to <strong>R</strong> and tested them with the <code>nls()</code> function of which he was a major author. I built a related package to allow the same problems to be approached as unconstrained function minimization problems, which I named <code>NISTopt</code>. However, this package was, when I prepared it in 2009, incomplete, particularly in respect to the manuals (Rd files). This vignette is an attempt to better document that effort and in the process force a review of the package. Furthermore, it raises the question of how to <strong>efficiently</strong> add and run new test problems.</p>
<p>Note that the problems here are <strong>NOT</strong> always good illustrations of tasks to which the various function minimization tools should be applied. However, they do suggest limits of performance of these tools.</p>
<p>In <strong>R</strong> circles, function minimization is often called “optimization”, though that generally implies that there are also constraints.</p>
</div>
<div id="approach-and-review-of-a-previous-effort" class="section level1">
<h1>Approach and review of a previous effort</h1>
<p>We need to be able to set things up so that a separate command is not needed for each start or example. Such a structure needs a lot of careful thought to avoid awkwardness. In particular, the existing trial (from 2008/9) of package <code>NISTopt</code> shows that its structure has a lot of code, much of which is common in nature. Moreover, we want to be able to add new problems easily. Furthermore the “Name.setup” functions do not seem very helpful for the long term.</p>
<div id="restrictions-on-the-problems" class="section level2">
<h2>Restrictions on the problems</h2>
<p>We do not wish (at the moment) to include general optimization problems with general constraints. In fact, we will limit our attention to at most bounds constrained nonlinear optimization and nonlinear least squares problems. There are, however, a lot of these. By considering lower and upper bounds that are equal, we can extend the constraints to fixed or <strong>masked</strong> parameters.</p>
</div>
</div>
<div id="design-i" class="section level1">
<h1>Design I</h1>
<p>We may be willing to have a single file to describe a single (but more or less complete) problem, but we ultimately want a <strong>set</strong> of problems, all of which can be accessed through a single structure. Through some experiments, detailed in <em>Appendix A: Use of a data frame</em>, we find that one could, if desired, store the problems in a data frame. Other structures are, of course, equally possible.</p>
<p>Using a data frame may, however, be overly complex. With suitable tools, one should be able to easily create and manipulate the objects created in the flat (i.e., plain text) file of a single problem.</p>
<p>This design is not, of course, the only possibility. However, it is likely that something based on the “single problem” <strong>R</strong> code file illustrated in the next section will prove useful.</p>
<div id="a-single-problem" class="section level2">
<h2>A single problem</h2>
<p>Let us consider how we might, in <strong>R</strong>, specify a nonlinear least squares problem that also can be presented as an optimization problem. Here is a possible file for the problem of <span class="citation">Daniel and Wood (1980)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># This is file DanielWood.prb</span>
probname &lt;-<span class="st"> &quot;DanielWood&quot;</span>
probdesc &lt;-<span class="st"> &quot;These data and model are described in Daniel and Wood (1980), and</span>
<span class="st">originally published in E.S.Keeping, 'Introduction to Statistical Inference,'</span>
<span class="st">Van Nostrand Company, Princeton, NJ, 1962, p. 354. The response variable is </span>
<span class="st">energy radieted from a carbon filament lamp per cm**2 per second, and the </span>
<span class="st">predictor variable is the absolute temperature of the filament in 1000 degrees Kelvin. </span>
<span class="st">&quot;</span>
probtype &lt;-<span class="st"> &quot;nls&quot;</span> <span class="co"># nls offers more possibilities than function minimization</span>
<span class="co">#- Other types??  &quot;fmin&quot;, &quot;ssmin&quot; (for resid ss)</span>
mformula &lt;-<span class="st"> </span>( y ~<span class="st"> </span>b1*x**b2 )
<span class="co">#- The above is a &quot;formula&quot;. But we could also possibl also use a character string or expression,</span>
<span class="co">#- but need to know how to do so carefully. ??</span>
##- ?? mdata=DanielWood # This would work if we have a data package, but not useful independently
<span class="co">#- This is the local data frame. We need to rename this when we put it into a global structure</span>
<span class="co">#- Now add various functions for optimization or nls-by-function</span>
<span class="co">#- ?? We could have problems with quotation marks WITHIN the code.</span>

DanielWood.f &lt;-<span class="st"> </span>function(x) {
res&lt;-<span class="kw">DanielWood.res</span>(x)
f&lt;-<span class="kw">sum</span>(res*res)
}

<span class="co">#- resfn</span>
DanielWood.res &lt;-<span class="st"> </span>function(b) {
xx&lt;-DanielWood.df$x <span class="co"># case !!</span>
yy&lt;-DanielWood.df$y
res &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(xx))
b1&lt;-b[<span class="dv">1</span>]
b2&lt;-b[<span class="dv">2</span>]
res&lt;-b1*(xx**b2) -<span class="st"> </span>yy
<span class="kw">return</span>(res)
}

<span class="co">#- jacfn</span>
<span class="co"># DanielWood - Jacobian</span>
DanielWood.jac &lt;-<span class="st"> </span>function(b) {
xx&lt;-DanielWood.df$x
yy&lt;-DanielWood.df$y
n&lt;-<span class="kw">length</span>(b)
m&lt;-<span class="kw">length</span>(xx)
b1&lt;-b[<span class="dv">1</span>]
b2&lt;-b[<span class="dv">2</span>]
J&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,m,n) <span class="co"># define the size of the Jacobian</span>
expr1 &lt;-<span class="st"> </span>xx^b2
J[, <span class="dv">1</span>] &lt;-<span class="st"> </span>expr1
J[, <span class="dv">2</span>] &lt;-<span class="st"> </span>b1 *<span class="st"> </span>(expr1 *<span class="st"> </span><span class="kw">log</span>(xx))
<span class="kw">return</span>(J)
}

<span class="co">#- hessfn</span>
DanielWood.h &lt;-<span class="st"> </span>function(x) {
JJ&lt;-<span class="kw">DanielWood.jac</span>(x)
H &lt;-<span class="st"> </span><span class="kw">t</span>(JJ) %*%<span class="st"> </span>JJ
res&lt;-<span class="kw">DanielWood.res</span>(x)
}

<span class="co">#- gr</span>
DanielWood.g&lt;-function(x) {
<span class="co">#-   stop('not defined')</span>
JJ&lt;-<span class="kw">DanielWood.jac</span>(x)
res&lt;-<span class="kw">DanielWood.res</span>(x)
gg&lt;-<span class="kw">as.vector</span>(<span class="fl">2.0</span>*<span class="kw">t</span>(JJ) %*%<span class="st"> </span>res)
<span class="kw">return</span>(gg)
}

<span class="co">#- setup</span>
<span class="co">#- DanielWood.setup&lt;-function() {</span>
y &lt;-<span class="st"> </span><span class="kw">c</span>( <span class="fl">2.138</span>, <span class="fl">3.421</span>, <span class="fl">3.597</span>, <span class="fl">4.340</span>, <span class="fl">4.882</span>, <span class="fl">5.660</span>)
x &lt;-<span class="st"> </span><span class="kw">c</span>( <span class="fl">1.309</span>, <span class="fl">1.471</span>, <span class="fl">1.490</span>, <span class="fl">1.565</span>, <span class="fl">1.611</span>, <span class="fl">1.680</span>)
DanielWood.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(x,y)
<span class="kw">rm</span>(x)
<span class="kw">rm</span>(y)
start1 =<span class="st"> </span><span class="kw">c</span>(<span class="dt">b1=</span> <span class="dv">1</span>, <span class="dt">b2 =</span> <span class="dv">5</span>)
start2 =<span class="st"> </span><span class="kw">c</span>(<span class="dt">b1 =</span> <span class="fl">0.7</span>,<span class="dt">b2 =</span> <span class="dv">4</span>)
starts &lt;-<span class="st"> </span><span class="kw">rbind</span>(start1, start2)
<span class="co"># out&lt;-list(starts=starts, df=DanielWood.df)</span>
<span class="co">#- return(out)</span>
<span class="co">#- }</span>

<span class="co">#- pstart &lt;- c(b1= 1, b2 = 5) # fix later for more starts</span>

DanielWood.test&lt;-function() {
}   </code></pre></div>
</div>
<div id="tools-for-preparing-and-using-problem-files" class="section level2">
<h2>Tools for preparing and using problem files</h2>
<div id="access-to-files" class="section level3">
<h3>Access to files</h3>
<p>In order to use problem files, we need a way to list them, display their content in both summary and detail, and attempt to use them with various nonlinear least squares and/or function minimization software.</p>
<div id="command-line-file-lister-and-display-tool" class="section level4">
<h4>Command line file lister and display tool</h4>
<p>We need a tool that</p>
<ul>
<li><p>sets the directory where problems are found</p></li>
<li><p>lists the files</p></li>
<li><p>allows one file to be selected</p></li>
<li><p>displays information in a structured way (possibly according to some profile)</p></li>
<li><p>allows the profile for display to be edited somehow</p></li>
</ul>
<p>?? code here</p>
</div>
<div id="gui-file-lister-and-display-tool" class="section level4">
<h4>GUI file lister and display tool</h4>
<p>Likely tied into command line tool by allowing command line to be executed when mouse or pointer clicks are executed. Check existing GUI tools to see what is possible.</p>
<p>?? code here</p>
</div>
</div>
<div id="building-problem-files" class="section level3">
<h3>Building problem files</h3>
<div id="data-frame-or-matrix-to-source-vector" class="section level4">
<h4>Data frame or matrix to source vector</h4>
<p>If problem files are to be self contained, we do not want to need to access external files. The simplest way to present a variable to <strong>R</strong> is to input data as a simple list and then name it. To prepare the problem file, we therefore want to be able to get data into the local <strong>R</strong> environment and prepare the text for an assignment statement that contains a source vector.</p>
<p>?? code</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Use paste() to build the c(...) structure</span></code></pre></div>
</div>
</div>
</div>
<div id="running-problems" class="section level2">
<h2>Running problems</h2>
<p><code>runoptprob</code> – ?? how it should be used</p>
<ul>
<li><p>provide</p>
<p>– filename (at least the root)</p>
<p>– which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)</p>
<p>– choice of gradient function or approximation (gr= (gr, “grfwd”, etc.)) ?? optional?</p>
<p>– controls – as per the control list in programs</p>
<p>– other arguments ?? how to provide? dotargs as below?</p>
<p>– xdata or dotargs (how to specify might be interesting)</p>
<p>– timing control (e.g., microbenchmark or simple timing)</p></li>
<li><p>read output control profile (initially just use sink())</p></li>
<li><p>read the file and execute it (make sure it has <strong>R</strong> commands so we can actually source() it)</p></li>
<li><p>analyze the call to runprob and do the appropriate call</p></li>
<li><p>format output and extract and store summaries</p></li>
</ul>
<p>– this may be multilayerd and take a lot of work</p>
<p>– start with no formatting, and gradually add features</p>
<p>– need to save conditions</p>
<p>– make sure we have time/date stamp on all runs</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">runoptprob &lt;-<span class="st"> </span>function(<span class="dt">pfilename=</span><span class="ot">NULL</span>, <span class="dt">minmeth=</span><span class="st">'nls'</span>, <span class="dt">submeth=</span><span class="ot">NULL</span>, 
                       <span class="dt">nstart =</span> <span class="dv">0</span>, <span class="dt">options=</span><span class="kw">list</span>(<span class="dt">args=</span><span class="ot">NULL</span>, <span class="dt">control=</span><span class="ot">NULL</span>) ) {
  <span class="co">#- ?? Need to eval(parse()) ALL functions available, since f calls res etc.</span>
  <span class="co">#- Need to carefully ensure these exist to avoid errors??</span>
  <span class="co">#- ?? can we simplify and NOT have to eval(parse()) them, but simply source the prb file?</span>
  
  <span class="kw">print</span>(options$args)
  <span class="kw">print</span>(options$controls)
  optecho &lt;-<span class="st"> </span><span class="ot">TRUE</span> <span class="co"># temporarily at least, or put in a profile</span>
  <span class="co">#- Get the path to the files (where should these be? Probably somehow related to pkg)   </span>
  pfile &lt;-<span class="st"> </span><span class="kw">paste</span>(pfilename, <span class="st">&quot;.prb&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)
  <span class="kw">source</span>(pfile, <span class="dt">echo=</span>optecho) <span class="co"># -- filename (at least the root)</span>
  <span class="co">#- now have a lot of the information</span>
  
  <span class="co">#-    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)</span>
  
  <span class="co">#-    -- choice of gradient function or approximation (gr= (gr, &quot;grfwd&quot;, etc.))</span>
  
  <span class="co">#-    -- controls -- as per the control list in programs</span>
  
  <span class="co">#-    -- other arguments</span>
  
  <span class="co">#-    -- xdata or dotargs (how to specify might be interesting)</span>
  
  <span class="co">#-    -- timing control (e.g., microbenchmark or simple timing)</span>
  
  <span class="co">#-  - read output control profile (initially just use sink())</span>
  <span class="co">#-  -- make sure we have time/date stamp on all runs</span>
  fname&lt;-<span class="kw">paste</span>(pfilename, <span class="kw">format</span>(<span class="kw">Sys.time</span>(), <span class="st">&quot;%Y%m%d%H%M&quot;</span>),<span class="st">&quot;.out&quot;</span>,<span class="dt">sep=</span><span class="st">''</span>)
  <span class="kw">sink</span>(fname, <span class="dt">append=</span><span class="ot">TRUE</span>, <span class="dt">split=</span><span class="ot">TRUE</span>)
  
  <span class="co">#-  - read the file and execute it (make sure it has **R** commands so we can</span>
  <span class="co">#-   actually source() it)</span>
  <span class="co">#- ?? not needed eval(parse(text=paste(pfilename,&quot;.setup&quot;, sep=''))) #- setup function</span>
  <span class="co">#- get the data and the starts</span>
  dfname &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.df&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
  <span class="kw">print</span>(dfname)
  
  <span class="co">#- - analyze the call to runprob and do the appropriate call</span>
  
  <span class="co">#- - format output and extract and store summaries</span>
  
  <span class="co">#-  -- this may be multilayerd and take a lot of work</span>
  
  <span class="co">#-  -- start with no formatting, and gradually add features</span>
  
  <span class="co">#-  -- need to save conditions</span>
  if (nstart ==<span class="st"> </span><span class="dv">0</span>) { <span class="co"># need to loop</span>
    nst &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>:<span class="st"> </span><span class="kw">dim</span>(starts)[<span class="dv">1</span>])
  } else { nst &lt;-<span class="st"> </span>nstart }
  if (minmeth ==<span class="st"> 'nls'</span>) {
    for (istrt in nst){
      <span class="co">#- ?? need to extract options and arguments like trace</span>
      <span class="co">#- some documentation output needed ??</span>
      sol &lt;-<span class="st"> </span><span class="kw">nls</span>(mformula, <span class="dt">data=</span>dfname, <span class="dt">start=</span>starts[istrt,], <span class="dt">trace=</span><span class="ot">TRUE</span>)      
      <span class="kw">print</span>(sol)
      <span class="kw">print</span>(<span class="kw">summary</span>(sol))
    }    
  }  
  if (minmeth ==<span class="st"> 'nlxb'</span>) {
      <span class="kw">require</span>(nlmrt)
      for (istrt in nst){
      <span class="co">#- ?? need to extract options and arguments like trace</span>
      <span class="co">#- some documentation output needed ??</span>
      sol &lt;-<span class="st"> </span><span class="kw">nlxb</span>(mformula, <span class="dt">data=</span>dfname, <span class="dt">start=</span>starts[istrt,], <span class="dt">trace=</span><span class="ot">TRUE</span>)      
      <span class="kw">print</span>(sol)
      <span class="kw">print</span>(<span class="kw">summary</span>(sol))
    }    
  }  
  if (minmeth ==<span class="st"> &quot;optimr&quot;</span>) {
     <span class="kw">require</span>(optimrx)
    <span class="co">#- here need to check if they exist??</span>
     ufn &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.f&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.res&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.jac&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.g&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     if( <span class="kw">is.null</span>(options$args[[<span class="st">&quot;gr&quot;</span>]]) ||<span class="st"> </span>!<span class="st"> </span><span class="kw">is.character</span>(options$args[[<span class="st">&quot;gr&quot;</span>]]) ) {
       <span class="co">#- name.gr now a function      </span>
       ugr &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.g&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     } else { ugr &lt;-<span class="st"> </span>(options$args[[<span class="st">&quot;gr&quot;</span>]]) }
     ufn &lt;-<span class="st">  </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">paste</span>(pfilename,<span class="st">&quot;.f&quot;</span>, <span class="dt">sep=</span><span class="st">''</span>)))
     for (istrt in nst){
        sol &lt;-<span class="st"> </span><span class="kw">optimr</span>(starts[istrt,], ufn, ugr, <span class="dt">method=</span>submeth, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">trace=</span><span class="dv">1</span>))
        <span class="kw">print</span>(sol)
     }
  }
    <span class="co">#- result should be a list of things run</span>
  <span class="kw">sink</span>()
  testsol &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">pfilename=</span>pfilename, <span class="dt">nstart=</span>nstart, <span class="dt">minmeth=</span>minmeth, <span class="dt">submeth=</span>submeth)
}</code></pre></div>
</div>
<div id="running-multiple-problems" class="section level2">
<h2>Running multiple problems</h2>
<ul>
<li><p>prepare “problem list”, like a play list</p></li>
<li><p>run them in sequence</p></li>
<li><p>try to figure out how to save the output</p>
<p>– sink</p>
<p>– summaries</p>
<p>– test against expected output</p>
<p>– timings</p>
<p>– measures of success</p></li>
</ul>
<p>For the moment, let us just call runoptprob(). Note that it creates a sinkfile for each call.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pfname &lt;-<span class="st"> &quot;DanielWood&quot;</span>
<span class="co"># try it</span>
test1 &lt;-<span class="st"> </span><span class="kw">runoptprob</span>(<span class="dt">pfilename=</span>pfname, <span class="dt">minmeth=</span><span class="st">&quot;nls&quot;</span>)</code></pre></div>
<pre><code>## NULL
## NULL
## 
## &gt; probname &lt;- &quot;DanielWood&quot;
## 
## &gt; probdesc &lt;- &quot;These data and model are described in Daniel and Wood (1980), and\noriginally published in E.S.Keeping, 'Introduction to Statistical In ...&quot; ... [TRUNCATED] 
## 
## &gt; probtype &lt;- &quot;nls&quot;
## 
## &gt; mformula &lt;- (y ~ b1 * x^b2)
## 
## &gt; DanielWood.f &lt;- function(x) {
## +     res &lt;- DanielWood.res(x)
## +     f &lt;- sum(res * res)
## + }
## 
## &gt; DanielWood.res &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     res &lt;- rep(NA, length(xx))
## +     b1 &lt;- b[1]
## +     b2 &lt; .... [TRUNCATED] 
## 
## &gt; DanielWood.jac &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     n &lt;- length(b)
## +     m &lt;- length(xx)
## +     b1 &lt;- b[1]
##  .... [TRUNCATED] 
## 
## &gt; DanielWood.h &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     H &lt;- t(JJ) %*% JJ
## +     res &lt;- DanielWood.res(x)
## + }
## 
## &gt; DanielWood.g &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     res &lt;- DanielWood.res(x)
## +     gg &lt;- as.vector(2 * t(JJ) %*% res)
## +     return(gg) .... [TRUNCATED] 
## 
## &gt; y &lt;- c(2.138, 3.421, 3.597, 4.34, 4.882, 5.66)
## 
## &gt; x &lt;- c(1.309, 1.471, 1.49, 1.565, 1.611, 1.68)
## 
## &gt; DanielWood.df &lt;- data.frame(x, y)
## 
## &gt; rm(x)
## 
## &gt; rm(y)
## 
## &gt; start1 = c(b1 = 1, b2 = 5)
## 
## &gt; start2 = c(b1 = 0.7, b2 = 4)
## 
## &gt; starts &lt;- rbind(start1, start2)
## 
## &gt; DanielWood.test &lt;- function() {
## + }
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660
## 149.7192 :  1 5
## 4.610878 :  0.7061691 4.4567375
## 0.03168417 :  0.7499191 3.9483634
## 0.004320594 :  0.7685973 3.8607752
## 0.004317308 :  0.7688633 3.8604026
## 0.004317308 :  0.7688623 3.8604056
## Nonlinear regression model
##   model: y ~ b1 * x^b2
##    data: dfname
##     b1     b2 
## 0.7689 3.8604 
##  residual sum-of-squares: 0.004317
## 
## Number of iterations to convergence: 5 
## Achieved convergence tolerance: 2.529e-07
## 
## Formula: y ~ b1 * x^b2
## 
## Parameters:
##    Estimate Std. Error t value Pr(&gt;|t|)    
## b1  0.76886    0.01828   42.06 1.91e-06 ***
## b2  3.86041    0.05173   74.63 1.93e-07 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.03285 on 4 degrees of freedom
## 
## Number of iterations to convergence: 5 
## Achieved convergence tolerance: 2.529e-07
## 
## 0.1037647 :  0.7 4.0
## 0.005930406 :  0.7679852 3.8542844
## 0.004317316 :  0.7688429 3.8604767
## 0.004317308 :  0.7688625 3.8604050
## Nonlinear regression model
##   model: y ~ b1 * x^b2
##    data: dfname
##     b1     b2 
## 0.7689 3.8604 
##  residual sum-of-squares: 0.004317
## 
## Number of iterations to convergence: 3 
## Achieved convergence tolerance: 5.447e-06
## 
## Formula: y ~ b1 * x^b2
## 
## Parameters:
##    Estimate Std. Error t value Pr(&gt;|t|)    
## b1  0.76886    0.01828   42.06 1.91e-06 ***
## b2  3.86041    0.05173   74.63 1.93e-07 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.03285 on 4 degrees of freedom
## 
## Number of iterations to convergence: 3 
## Achieved convergence tolerance: 5.447e-06</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test1</code></pre></div>
<pre><code>## $pfilename
## [1] &quot;DanielWood&quot;
## 
## $nstart
## [1] 0
## 
## $minmeth
## [1] &quot;nls&quot;
## 
## $submeth
## NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">readline</span>(<span class="st">&quot;continue&quot;</span>)</code></pre></div>
<pre><code>## continue</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test2 &lt;-<span class="st"> </span><span class="kw">runoptprob</span>(<span class="dt">pfilename=</span>pfname, <span class="dt">minmeth=</span><span class="st">&quot;nlxb&quot;</span>)</code></pre></div>
<pre><code>## NULL
## NULL
## 
## &gt; probname &lt;- &quot;DanielWood&quot;
## 
## &gt; probdesc &lt;- &quot;These data and model are described in Daniel and Wood (1980), and\noriginally published in E.S.Keeping, 'Introduction to Statistical In ...&quot; ... [TRUNCATED] 
## 
## &gt; probtype &lt;- &quot;nls&quot;
## 
## &gt; mformula &lt;- (y ~ b1 * x^b2)
## 
## &gt; DanielWood.f &lt;- function(x) {
## +     res &lt;- DanielWood.res(x)
## +     f &lt;- sum(res * res)
## + }
## 
## &gt; DanielWood.res &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     res &lt;- rep(NA, length(xx))
## +     b1 &lt;- b[1]
## +     b2 &lt; .... [TRUNCATED] 
## 
## &gt; DanielWood.jac &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     n &lt;- length(b)
## +     m &lt;- length(xx)
## +     b1 &lt;- b[1]
##  .... [TRUNCATED] 
## 
## &gt; DanielWood.h &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     H &lt;- t(JJ) %*% JJ
## +     res &lt;- DanielWood.res(x)
## + }
## 
## &gt; DanielWood.g &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     res &lt;- DanielWood.res(x)
## +     gg &lt;- as.vector(2 * t(JJ) %*% res)
## +     return(gg) .... [TRUNCATED] 
## 
## &gt; y &lt;- c(2.138, 3.421, 3.597, 4.34, 4.882, 5.66)
## 
## &gt; x &lt;- c(1.309, 1.471, 1.49, 1.565, 1.611, 1.68)
## 
## &gt; DanielWood.df &lt;- data.frame(x, y)
## 
## &gt; rm(x)
## 
## &gt; rm(y)
## 
## &gt; start1 = c(b1 = 1, b2 = 5)
## 
## &gt; start2 = c(b1 = 0.7, b2 = 4)
## 
## &gt; starts &lt;- rbind(start1, start2)
## 
## &gt; DanielWood.test &lt;- function() {
## + }
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660</code></pre>
<pre><code>## Loading required package: nlmrt</code></pre>
<pre><code>## formula: y ~ b1 * x^b2
## lower:[1] -Inf -Inf
## upper:[1] Inf Inf
## $watch
## [1] FALSE
## 
## $phi
## [1] 1
## 
## $lamda
## [1] 1e-04
## 
## $offset
## [1] 100
## 
## $laminc
## [1] 10
## 
## $lamdec
## [1] 4
## 
## $femax
## [1] 10000
## 
## $jemax
## [1] 5000
## 
## $rofftest
## [1] TRUE
## 
## $smallsstest
## [1] TRUE
## 
## Data variable  y :[1] 2.138 3.421 3.597 4.340 4.882 5.660
## Data variable  x :[1] 1.309 1.471 1.490 1.565 1.611 1.680
## ssminval = 3.639473e-53 
## Start:lamda: 1e-04  SS= 149.7192  at  b1 = 1  b2 = 5  1 / 0
## roff = 0.08104665   converged =  FALSE 
## delta:        b1         b2 
## -0.2935688 -0.5437644 
## gjty:       [,1]
## b1 273.4627
## b2 127.6840
## gradient projection =  -149.7101  g-delta-angle= 143.3924 
## Stepsize= 1 
## &lt;&lt;lamda: 4e-05  SS= 4.617901  at  b1 = 0.7064312  b2 = 4.456236  2 / 1
## roff = 0.01403555   converged =  FALSE 
## delta:         b1          b2 
##  0.04300627 -0.50629468 
## gjty:       [,1]
## b1 36.84083
## b2 12.24312
## gradient projection =  -4.614241  g-delta-angle= 103.5277 
## Stepsize= 1 
## &lt;&lt;lamda: 1.6e-05  SS= 0.03204775  at  b1 = 0.7494375  b2 = 3.949941  3 / 2
## roff = 0.001038332   converged =  FALSE 
## delta:         b1          b2 
##  0.01910095 -0.08902608 
## gjty:        [,1]
## b1 2.1613197
## b2 0.7754481
## gradient projection =  -0.02775185  g-delta-angle= 97.62772 
## Stepsize= 1 
## &lt;&lt;lamda: 6.4e-06  SS= 0.00432114  at  b1 = 0.7685384  b2 = 3.860915  4 / 3
## roff = 1.280769e-05   converged =  FALSE 
## delta:           b1            b2 
##  0.0003250606 -0.0005128129 
## gjty:           [,1]
## b1 -0.025599344
## b2 -0.008753529
## gradient projection =  -3.832416e-06  g-delta-angle= 103.4919 
## Stepsize= 1 
## &lt;&lt;lamda: 2.56e-06  SS= 0.004317308  at  b1 = 0.7688635  b2 = 3.860402  5 / 4
## roff = 1.531446e-08   converged =  TRUE 
## delta:           b1            b2 
## -1.215752e-06  3.633677e-06 
## gjty:            [,1]
## b1 -9.960217e-06
## b2 -4.954001e-06
## gradient projection =  -5.892083e-12  g-delta-angle= 97.94562 
## Stepsize= 1 
## &lt;&lt;lamda: 1.024e-06  SS= 0.004317308  at  b1 = 0.7688623  b2 = 3.860406  6 / 5
## nlmrt class object: x 
## residual sumsquares =  0.0043173  on  6 observations
##     after  5    Jacobian and  6 function evaluations
##   name            coeff          SE       tstat      pval      gradient    JSingval   
## b1              0.768862       0.01828      42.06  1.911e-06    3.85e-10       14.05  
## b2               3.86041       0.05173      74.63  1.932e-07  -2.715e-10      0.5994  
## $resname
## [1] &quot;sol&quot;
## 
## $ssquares
## [1] 0.0043173
## 
## $nobs
## [1] 6
## 
## $coeff
##      b1      b2 
## 0.76886 3.86041 
## 
## $ct
## [1] &quot; &quot; &quot; &quot;
## 
## $mt
## [1] &quot; &quot; &quot; &quot;
## 
## $SEs
## [1] 0.018282 0.051727
## 
## $tstat
##     b1     b2 
## 42.056 74.631 
## 
## $pval
##         b1         b2 
## 1.9108e-06 1.9318e-07 
## 
## $Sd
## [1] 14.04921  0.59937
## 
## $gr
##           [,1]
## b1  3.8503e-10
## b2 -2.7148e-10
## 
## $jeval
## [1] 5
## 
## $feval
## [1] 6
## 
## formula: y ~ b1 * x^b2
## lower:[1] -Inf -Inf
## upper:[1] Inf Inf
## $watch
## [1] FALSE
## 
## $phi
## [1] 1
## 
## $lamda
## [1] 1e-04
## 
## $offset
## [1] 100
## 
## $laminc
## [1] 10
## 
## $lamdec
## [1] 4
## 
## $femax
## [1] 10000
## 
## $jemax
## [1] 5000
## 
## $rofftest
## [1] TRUE
## 
## $smallsstest
## [1] TRUE
## 
## Data variable  y :[1] 2.138 3.421 3.597 4.340 4.882 5.660
## Data variable  x :[1] 1.309 1.471 1.490 1.565 1.611 1.680
## ssminval = 2.5224e-56 
## Start:lamda: 1e-04  SS= 0.10376  at  b1 = 0.7  b2 = 4  1 / 0
## roff = 0.27419   converged =  FALSE 
## delta:      b1       b2 
##  0.06734 -0.14372 
## gjty:      [,1]
## b1 -4.2765
## b2 -1.3123
## gradient projection =  -0.099372  g-delta-angle= 98.046 
## Stepsize= 1 
## &lt;&lt;lamda: 4e-05  SS= 0.0058663  at  b1 = 0.76734  b2 = 3.8563  2 / 1
## roff = 0.035577   converged =  FALSE 
## delta:       b1        b2 
## 0.0015102 0.0041697 
## gjty:       [,1]
## b1 -0.51966
## b2 -0.18327
## gradient projection =  -0.001549  g-delta-angle= 129.34 
## Stepsize= 1 
## &lt;&lt;lamda: 1.6e-05  SS= 0.0043173  at  b1 = 0.76885  b2 = 3.8605  3 / 2
## roff = 5.0601e-05   converged =  FALSE 
## delta:         b1          b2 
##  1.2589e-05 -4.7982e-05 
## gjty:         [,1]
## b1 0.00074052
## b2 0.00027869
## gradient projection =  -4.0498e-09  g-delta-angle= 95.922 
## Stepsize= 1 
## &lt;&lt;lamda: 6.4e-06  SS= 0.0043173  at  b1 = 0.76886  b2 = 3.8604  4 / 3
## roff = 1.7412e-07   converged =  FALSE 
## delta:         b1          b2 
## -1.0563e-07  3.0249e-07 
## gjty:          [,1]
## b1 -5.1091e-08
## b2 -1.4000e-07
## gradient projection =  -3.6951e-14  g-delta-angle= 140.7 
## Stepsize= 1 
## &lt;&lt;lamda: 2.56e-06  SS= 0.0043173  at  b1 = 0.76886  b2 = 3.8604  5 / 4
## roff = 1.2461e-09   converged =  TRUE 
## delta:         b1          b2 
##  7.5754e-10 -2.1652e-09 
## gjty:         [,1]
## b1 1.1826e-10
## b2 9.1510e-10
## gradient projection =  -1.8918e-18  g-delta-angle= 153.35 
## Stepsize= 1 
## lamda: 2.56e-05  SS= 0.0043173  at  b1 = 0.76886  b2 = 3.8604  6 / 5
## nlmrt class object: x 
## residual sumsquares =  0.0043173  on  6 observations
##     after  5    Jacobian and  6 function evaluations
##   name            coeff          SE       tstat      pval      gradient    JSingval   
## b1              0.768862       0.01828      42.06  1.911e-06   1.183e-10       14.05  
## b2               3.86041       0.05173      74.63  1.932e-07   9.151e-10      0.5994  
## $resname
## [1] &quot;sol&quot;
## 
## $ssquares
## [1] 0.0043173
## 
## $nobs
## [1] 6
## 
## $coeff
##      b1      b2 
## 0.76886 3.86041 
## 
## $ct
## [1] &quot; &quot; &quot; &quot;
## 
## $mt
## [1] &quot; &quot; &quot; &quot;
## 
## $SEs
## [1] 0.018282 0.051727
## 
## $tstat
##     b1     b2 
## 42.056 74.631 
## 
## $pval
##         b1         b2 
## 1.9108e-06 1.9318e-07 
## 
## $Sd
## [1] 14.04923  0.59937
## 
## $gr
##          [,1]
## b1 1.1826e-10
## b2 9.1510e-10
## 
## $jeval
## [1] 5
## 
## $feval
## [1] 6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test2</code></pre></div>
<pre><code>## $pfilename
## [1] &quot;DanielWood&quot;
## 
## $nstart
## [1] 0
## 
## $minmeth
## [1] &quot;nlxb&quot;
## 
## $submeth
## NULL</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tmp &lt;-<span class="st"> </span><span class="kw">readline</span>(<span class="st">&quot;continue&quot;</span>)</code></pre></div>
<pre><code>## continue</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test3 &lt;-<span class="st"> </span><span class="kw">runoptprob</span>(<span class="dt">pfilename=</span>pfname, <span class="dt">minmeth=</span><span class="st">&quot;optimr&quot;</span>, <span class="dt">submeth=</span><span class="st">&quot;L-BFGS-B&quot;</span>)</code></pre></div>
<pre><code>## NULL
## NULL
## 
## &gt; probname &lt;- &quot;DanielWood&quot;
## 
## &gt; probdesc &lt;- &quot;These data and model are described in Daniel and Wood (1980), and\noriginally published in E.S.Keeping, 'Introduction to Statistical In ...&quot; ... [TRUNCATED] 
## 
## &gt; probtype &lt;- &quot;nls&quot;
## 
## &gt; mformula &lt;- (y ~ b1 * x^b2)
## 
## &gt; DanielWood.f &lt;- function(x) {
## +     res &lt;- DanielWood.res(x)
## +     f &lt;- sum(res * res)
## + }
## 
## &gt; DanielWood.res &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     res &lt;- rep(NA, length(xx))
## +     b1 &lt;- b[1]
## +     b2 &lt; .... [TRUNCATED] 
## 
## &gt; DanielWood.jac &lt;- function(b) {
## +     xx &lt;- DanielWood.df$x
## +     yy &lt;- DanielWood.df$y
## +     n &lt;- length(b)
## +     m &lt;- length(xx)
## +     b1 &lt;- b[1]
##  .... [TRUNCATED] 
## 
## &gt; DanielWood.h &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     H &lt;- t(JJ) %*% JJ
## +     res &lt;- DanielWood.res(x)
## + }
## 
## &gt; DanielWood.g &lt;- function(x) {
## +     JJ &lt;- DanielWood.jac(x)
## +     res &lt;- DanielWood.res(x)
## +     gg &lt;- as.vector(2 * t(JJ) %*% res)
## +     return(gg) .... [TRUNCATED] 
## 
## &gt; y &lt;- c(2.138, 3.421, 3.597, 4.34, 4.882, 5.66)
## 
## &gt; x &lt;- c(1.309, 1.471, 1.49, 1.565, 1.611, 1.68)
## 
## &gt; DanielWood.df &lt;- data.frame(x, y)
## 
## &gt; rm(x)
## 
## &gt; rm(y)
## 
## &gt; start1 = c(b1 = 1, b2 = 5)
## 
## &gt; start2 = c(b1 = 0.7, b2 = 4)
## 
## &gt; starts &lt;- rbind(start1, start2)
## 
## &gt; DanielWood.test &lt;- function() {
## + }
##       x     y
## 1 1.309 2.138
## 2 1.471 3.421
## 3 1.490 3.597
## 4 1.565 4.340
## 5 1.611 4.882
## 6 1.680 5.660</code></pre>
<pre><code>## Loading required package: optimrx</code></pre>
<pre><code>## Unit parameter scaling
## iter   10 value 0.011817
## final  value 0.004317 
## converged
## $par
##      b1      b2 
## 0.76885 3.86043 
## 
## $value
## [1] 0.0043173
## 
## $counts
## function gradient 
##       21       21 
## 
## $convergence
## [1] 0
## 
## $message
## [1] &quot;CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH&quot;
## 
## Unit parameter scaling
## iter   10 value 0.004317
## final  value 0.004317 
## converged
## $par
##      b1      b2 
## 0.76886 3.86041 
## 
## $value
## [1] 0.0043173
## 
## $counts
## function gradient 
##       14       14 
## 
## $convergence
## [1] 0
## 
## $message
## [1] &quot;CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">test3</code></pre></div>
<pre><code>## $pfilename
## [1] &quot;DanielWood&quot;
## 
## $nstart
## [1] 0
## 
## $minmeth
## [1] &quot;optimr&quot;
## 
## $submeth
## [1] &quot;L-BFGS-B&quot;</code></pre>
</div>
<div id="appendix-a-use-of-a-data-frame" class="section level2">
<h2>Appendix A: Use of a data frame</h2>
<p>The following script shows that we can store problem materials, including functions, <strong>INSIDE</strong> an <strong>R</strong> data frame.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(NISTO)
<span class="kw">ls</span>(package:NISTO)
NISTO::DanielWood.res
NISTO:::DanielWood.res
f1 &lt;-<span class="st"> </span>y ~<span class="st"> </span>(b1+x*(b2+x*(b3+b4*x))) /<span class="st"> </span>(<span class="dv">1</span>+x*(b5+x*(b6+x*b7)))
<span class="kw">str</span>(f1)
?NISTO
?DanielWood
<span class="kw">data</span>(DanielWood)
DanielWood
dwprob &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mform =</span> f1, <span class="dt">mdata=</span>DanielWood, <span class="dt">pname=</span><span class="st">&quot;DanielWood&quot;</span>, <span class="dt">ptype=</span><span class="st">&quot;nls&quot;</span>)
dwprob
<span class="kw">data</span>()
f2 &lt;-<span class="st"> </span>y ~<span class="st"> </span>b1 /<span class="st"> </span>(<span class="dv">1</span>+<span class="kw">exp</span>(b2-b3*x))
r2data &lt;-Ratkowsky2
r2data
r2prob &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mform =</span> f2, <span class="dt">mdata=</span>Ratkowsky2, <span class="dt">pname=</span><span class="st">&quot;Ratkowsky2&quot;</span>, <span class="dt">ptype=</span><span class="st">&quot;nls&quot;</span>)
r2prob
myprobs &lt;-<span class="st"> </span><span class="kw">rbind</span>(dwprob, r2prob)
myprobs
<span class="kw">str</span>(myprobs)
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(myprobs)
<span class="kw">str</span>(myprobs.d)
f3 &lt;-<span class="st"> </span>y ~<span class="st"> </span><span class="kw">exp</span>(-b1*x)/(b2+b3*x)
c1data &lt;-<span class="st"> </span>Chwirut1
c1name &lt;-<span class="st"> &quot;Chwirut1&quot;</span>
c1prob &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mform =</span> f3, <span class="dt">mdata=</span>Chwirut1, <span class="dt">pname=</span>c1name, <span class="dt">ptype=</span><span class="st">&quot;nls&quot;</span>)
myprobs.d[<span class="dv">3</span>,] &lt;-<span class="st"> </span>c1prob
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.dataframe</span>(<span class="kw">rbind</span>(myprobs.d, c1prob))
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">rbind</span>(myprobs.d, c1prob))
myprobs.d &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">rbind</span>(myprobs, c1prob))
myprobs.d
<span class="kw">str</span>(myprobs.d)
myprobs.d[,<span class="dv">5</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>
<span class="kw">str</span>(myprobs.d)
<span class="kw">colnames</span>(myprobs.d[,<span class="dv">5</span>] &lt;-<span class="st"> &quot;resfn&quot;</span>)
<span class="kw">colnames</span>(myprobs.d[,<span class="dv">5</span>]) &lt;-<span class="st"> &quot;resfn&quot;</span>
<span class="kw">colnames</span>(myprobs.d)[<span class="dv">5</span>] &lt;-<span class="st"> &quot;resfn&quot;</span>
myprobs.d
DanielWood.res &lt;-<span class="st"> </span>function(b) {
   xx&lt;-DanielWood$x <span class="co"># case !!</span>
   yy&lt;-DanielWood$y
   res &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="kw">length</span>(xx))
   b1&lt;-b[<span class="dv">1</span>]
   b2&lt;-b[<span class="dv">2</span>]
   res&lt;-b1*(xx**b2) -<span class="st"> </span>yy
   <span class="kw">return</span>(res)
}
myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>] &lt;-<span class="st"> </span>DanielWood.res
myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>] &lt;-<span class="st"> </span><span class="kw">quote</span>(DanielWood.res)
dwreschr &lt;-<span class="st"> &quot;DanielWood.res &lt;- function(b) {;xx&lt;-DanielWood$x; yy&lt;-DanielWood$y; res &lt;- rep(NA, length(xx)); b1&lt;-b[1];  b2&lt;-b[2];   res&lt;-b1*(xx**b2) - yy;   return(res);}&quot;</span>
myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>] &lt;-<span class="st"> </span>dwreschr
<span class="kw">ls</span>()
rm DanielWood.res
<span class="kw">rm</span>( DanielWood.res)
ls
<span class="kw">ls</span>()
<span class="kw">source</span>(<span class="st">&quot;myprobs.d[1,5])</span>
<span class="st">&quot;</span>
)
<span class="kw">source</span>(<span class="st">&quot;myprobs.d[1,5]&quot;</span>)
<span class="kw">source</span>(<span class="dt">text=</span><span class="st">&quot;myprobs.d[1,5]&quot;</span>)
?source
<span class="kw">parse</span>(<span class="dt">text=</span>myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>])
<span class="kw">ls</span>()
<span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span>myprobs.d[<span class="dv">1</span>,<span class="dv">5</span>]))
<span class="kw">ls</span>()
<span class="kw">savehistory</span>(<span class="st">&quot;NISTOx1.txt&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># NISTOx2.txt</span>
test &lt;-<span class="st"> &quot;</span>
<span class="st"># Chwirut1 - Jacobian</span>
<span class="st">Chwirut1.jac &lt;- function(b) {</span>
<span class="st">   xx&lt;-Chwirut1$x</span>
<span class="st">   yy&lt;-Chwirut1$y</span>
<span class="st">   n&lt;-length(b)</span>
<span class="st">   m&lt;-length(xx)</span>
<span class="st">   b1&lt;-b[1]</span>
<span class="st">   b2&lt;-b[2]</span>
<span class="st">   b3&lt;-b[3]</span>
<span class="st">   J&lt;-matrix(0,m,n) # define the size of the Jacobian</span>
<span class="st">   expr3 &lt;- exp(-b1 * xx)</span>
<span class="st">   expr5 &lt;- b2 + b3 * xx</span>
<span class="st">   expr7 &lt;- expr3 * xx</span>
<span class="st">   expr10 &lt;- expr5*expr5</span>
<span class="st">   value &lt;- expr3/expr5</span>
<span class="st">   J[,1] &lt;- -(expr7/expr5)</span>
<span class="st">   J[,2] &lt;- -(expr3/expr10)</span>
<span class="st">   J[,3] &lt;- -(expr7/expr10)</span>
<span class="st">   return(J)</span>
<span class="st">}</span>
<span class="st">&quot;</span>
ftest &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(test))
ftest &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span>test))
bstart &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)
<span class="kw">print</span>(<span class="kw">ftest</span>(bstart))
<span class="kw">savehistory</span>(<span class="st">&quot;NISTOx2.txt&quot;</span>)</code></pre></div>
<div id="refs" class="references">
<div id="ref-danwood1980">
<p>Daniel, C., and F. S. Wood. 1980. <em>Fitting Equations to Data: Computer Analysis of Multifactor Data, Second Edition</em>. Wiley.</p>
</div>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
