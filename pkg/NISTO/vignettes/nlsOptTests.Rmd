---
title: "A structure for building optimization and nonlinear least squares tests for **R**"
author: "John C. Nash"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# Motivation


http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml presents a number of nonlinear
regression (nonlinear least squares) problems that are more or less difficult to solve
numerically. Doug Bates prepared an **R** package `NISTnls` which adapted these problems
to **R** and tested them with the `nls()` function of which he was a major author.
I built a related package to allow the same problems to be approached as unconstrained function 
minimization problems, which I named `NISTopt`. However, this package was, when I prepared
it in 2009, incomplete, particularly in respect to the manuals (Rd files). This vignette
is an attempt to better document that effort and in the process force a review of the
package. Furthermore, it raises the question of how to **efficiently** add and run
new test problems. 

Note that the problems here are **NOT** always good illustrations of tasks to 
which the various
function minimization (also called "optimization", though that generally implies that there
are also constraints) tools should be applied. However, they do suggest limits 
of performance of these tools. 

# Approach

We need to be able to set things up so that a separate command is not needed for each start
or example. Such a structure needs a lot of careful thought to 
avoid awkwardness. In particular,
the existing trial (from 2008/9) of package `NISTopt` shows that its structure has a lot of
code, much of which is common in nature. Moreover, we want to be able to add new problems 
easily. Also the "Name.setup" functions do not seem very helpful for the long term.

## Restrictions on the problems

We do not wish (at the moment) to 
include general optimization problems with general constraints.
In fact, we will limit our attention to at most bounds constrained nonlinear optimization and
nonlinear least squares problems. There are, however, a lot of 
these. By considering lower and
upper bounds that are equal, we can extend the constraints to fixed or **masked** parameters.

# Design I

We may be willing to have a single file to describe a single (but more or less complete)
problem, but we ultimately want
a **set** of problems, all of which can be accessed through a single structure. Through 
some experiments, detailed in *Appendix A: Use of a data frame*, we find that one could,
if desired, store the problems in a data frame. Other structures are, of course, 
equally possible. 

Using a data frame may, however, be overly complex. With suitable tools, one should be
able to easily create and manipulate the objects created in the 
flat (i.e., plain text) file of a single problem. 

This design is not, of course, the only possibility. However, it is likely that something
based on the "single problem" **R** code file illustrated in the next section will prove
useful.

## A single problem

Let us consider how we might, in **R**, specify a nonlinear least squares problem that
also can be presented as an optimization problem. Here is a possible file for the 
problem of Daniel and Wood (??citation).

```{r}
probname <- "DanielWood"
probdesc <- "

?? need to put this in place

"
probtype <- "nls" # nls offers more possibilities than function minimization
mformula <- ( y ~ (b1+x*(b2+x*(b3+b4*x))) / (1+x*(b5+x*(b6+x*b7)) ) )
# The above is a "formula". But we could also possibl also use a character string or expression,
# but need to know how to do so carefully. ??
## ?? mdata=DanielWood # This would work if we have a data package, but not useful independently
y <- c( 2.138, 3.421, 3.597, 4.340, 4.882, 5.660)
x <- c( 1.309, 1.471, 1.490, 1.565, 1.611, 1.680)
dframe <- data.frame(x,y)
# This is the local data frame. We need to rename this when we put it into a global structure
# Now add various functions for optimization or nls-by-function
# ?? We could have problems with quotation marks WITHIN the code.
fn <- "
DanielWood.f <- function(x) {
   res<-DanielWood.res(x)
   f<-sum(res*res)
}"

resfn <- "DanielWood.res <- function(b) {
   xx<-DanielWood$x # case !!
   yy<-DanielWood$y
   res <- rep(NA, length(xx))
   b1<-b[1]
   b2<-b[2]
   res<-b1*(xx**b2) - yy
   return(res)
}"

jacfn <- "# DanielWood - Jacobian
DanielWood.jac <- function(b) {
   xx<-DanielWood$x
   yy<-DanielWood$y
   n<-length(b)
   m<-length(xx)
   b1<-b[1]
   b2<-b[2]
   J<-matrix(0,m,n) # define the size of the Jacobian
   expr1 <- xx^b2
   J[, 1] <- expr1
   J[, 2] <- b1 * (expr1 * log(xx))
   return(J)
}"

hessfn <- "DanielWood.h <- function(x) {
   JJ<-DanielWood.jac(x)
   H <- t(JJ) %*% JJ
   res<-DanielWood.res(x)
}"

gr <- "DanielWood.g<-function(x) {
#   stop('not defined')
   JJ<-DanielWood.jac(x)
   res<-DanielWood.res(x)
   gg<-as.vector(2.0*t(JJ) %*% res)
   return(gg)
}"

# setup functions
psetup <- "DanielWood.setup<-function() {
   data(DanielWood) # and load up the data into x and y
   start1 = c( 1, 5)
   start2 = c( 0.7, 4)
   out<-list(start1=start1, start2=start2)
   return(out)
}"

ptest <- "DanielWood.test<-function() {
}"   

# We can "install" these functions via eval(parse(name))

```

## Tools for preparing and using problem files

### Access to files

In order to use problem files, we need a way to list them, display their content in
both summary and detail, and attempt to use them with various nonlinear least squares
and/or function minimization software.

#### Command line file lister and display tool

We need a tool that 

- sets the directory where problems are found

- lists the files

- allows one file to be selected

- displays information in a structured way (possibly according to some profile)

- allows the profile for display to be edited somehow

#### GUI file lister and display tool

Likely tied into command line tool by allowing command line to be executed when
mouse or pointer clicks are executed. Check existing GUI tools to see what is 
possible.

### Building problem files

#### Data frame or matrix to source vector

If problem files are to be self contained, we do not want to need to access external
files. The simplest way to present a variable to **R** is to input data as a simple
list and then name it. To prepare the problem file, we therefore want to be able to
get data into the local **R** environment and prepare the text for an assignment
statement that contains a source vector.

?? code
```{r, eval=FALSE}

# Use paste() to build the c(...) structure

```


## Running problems

`runoptprob` -- ?? how it should be used

- provide 

    -- filename (at least the root)

    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)

    -- choice of gradient function or approximation (gr= (gr, "grfwd", etc.))

    -- controls -- as per the control list in programs

    -- other arguments

    -- xdata or dotargs (how to specify might be interesting)
    
    -- timing control (e.g., microbenchmark or simple timing)

- read output control profile (initially just use sink())

- read the file and execute it (make sure it has **R** commands so we can
actually source() it)

- analyze the call to runprob and do the appropriate call

- format output and extract and store summaries

  -- this may be multilayerd and take a lot of work
  
  -- start with no formatting, and gradually add features
  
  -- need to save conditions
  
  -- make sure we have time/date stamp on all runs

```{r}
runoptprob <- function(pfilename=NULL, minmeth='nls', submeth=NULL, 
                       options=list(args=NULL, control=NULL) ) {
    optecho <- TRUE # temporarily at least, or put in a profile
    # Get the path to the files (where should these be? Probably somehow related to pkg)   
    pfile <- paste(pfilename, ".prb", sep='')
    source(pfile, echo=optecho) # -- filename (at least the root)
    # now have a lot of the information

#    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)

#    -- choice of gradient function or approximation (gr= (gr, "grfwd", etc.))

#    -- controls -- as per the control list in programs

#    -- other arguments

#    -- xdata or dotargs (how to specify might be interesting)
    
#    -- timing control (e.g., microbenchmark or simple timing)

# - read output control profile (initially just use sink())

# - read the file and execute it (make sure it has **R** commands so we can
#   actually source() it)

# - analyze the call to runprob and do the appropriate call

# - format output and extract and store summaries

#  -- this may be multilayerd and take a lot of work
  
#  -- start with no formatting, and gradually add features
  
#  -- need to save conditions
  
#  -- make sure we have time/date stamp on all runs
  

}
```

## Running multiple problems

- prepare "problem list", like a play list

- run them in sequence

- try to figure out how to save the output 
    
    -- sink
    
    -- summaries
    
    -- test against expected output
    
    -- timings
    
    -- measures of success



## Appendix A: Use of a data frame

The following script shows that we can store problem materials, including functions,
**INSIDE** an **R** data frame.

```{r, eval=FALSE}
require(NISTO)
ls(package:NISTO)
NISTO::DanielWood.res
NISTO:::DanielWood.res
f1 <- y ~ (b1+x*(b2+x*(b3+b4*x))) / (1+x*(b5+x*(b6+x*b7)))
str(f1)
?NISTO
?DanielWood
data(DanielWood)
DanielWood
dwprob <- list(mform = f1, mdata=DanielWood, pname="DanielWood", ptype="nls")
dwprob
data()
f2 <- y ~ b1 / (1+exp(b2-b3*x))
r2data <-Ratkowsky2
r2data
r2prob <- list(mform = f2, mdata=Ratkowsky2, pname="Ratkowsky2", ptype="nls")
r2prob
myprobs <- rbind(dwprob, r2prob)
myprobs
str(myprobs)
myprobs.d <- as.data.frame(myprobs)
str(myprobs.d)
f3 <- y ~ exp(-b1*x)/(b2+b3*x)
c1data <- Chwirut1
c1name <- "Chwirut1"
c1prob <- list(mform = f3, mdata=Chwirut1, pname=c1name, ptype="nls")
myprobs.d[3,] <- c1prob
myprobs.d <- as.dataframe(rbind(myprobs.d, c1prob))
myprobs.d <- as.data.frame(rbind(myprobs.d, c1prob))
myprobs.d <- as.data.frame(rbind(myprobs, c1prob))
myprobs.d
str(myprobs.d)
myprobs.d[,5] <- NA
str(myprobs.d)
colnames(myprobs.d[,5] <- "resfn")
colnames(myprobs.d[,5]) <- "resfn"
colnames(myprobs.d)[5] <- "resfn"
myprobs.d
DanielWood.res <- function(b) {
   xx<-DanielWood$x # case !!
   yy<-DanielWood$y
   res <- rep(NA, length(xx))
   b1<-b[1]
   b2<-b[2]
   res<-b1*(xx**b2) - yy
   return(res)
}
myprobs.d[1,5] <- DanielWood.res
myprobs.d[1,5] <- quote(DanielWood.res)
dwreschr <- "DanielWood.res <- function(b) {;xx<-DanielWood$x; yy<-DanielWood$y; res <- rep(NA, length(xx)); b1<-b[1];  b2<-b[2];   res<-b1*(xx**b2) - yy;   return(res);}"
myprobs.d[1,5] <- dwreschr
ls()
rm DanielWood.res
rm( DanielWood.res)
ls
ls()
source("myprobs.d[1,5])
"
)
source("myprobs.d[1,5]")
source(text="myprobs.d[1,5]")
?source
parse(text=myprobs.d[1,5])
ls()
eval(parse(text=myprobs.d[1,5]))
ls()
savehistory("NISTOx1.txt")
```

```{r, eval=FALSE}
# NISTOx2.txt
test <- "
# Chwirut1 - Jacobian
Chwirut1.jac <- function(b) {
   xx<-Chwirut1$x
   yy<-Chwirut1$y
   n<-length(b)
   m<-length(xx)
   b1<-b[1]
   b2<-b[2]
   b3<-b[3]
   J<-matrix(0,m,n) # define the size of the Jacobian
   expr3 <- exp(-b1 * xx)
   expr5 <- b2 + b3 * xx
   expr7 <- expr3 * xx
   expr10 <- expr5*expr5
   value <- expr3/expr5
   J[,1] <- -(expr7/expr5)
   J[,2] <- -(expr3/expr10)
   J[,3] <- -(expr7/expr10)
   return(J)
}
"
ftest <- eval(parse(test))
ftest <- eval(parse(text=test))
bstart <- c(1,1,1)
print(ftest(bstart))
savehistory("NISTOx2.txt")
```