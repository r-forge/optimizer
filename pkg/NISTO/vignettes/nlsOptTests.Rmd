---
title: "A structure for building optimization and nonlinear least squares tests for **R**"
author: "John C. Nash and Paul Gilbert"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: nlsOptTests.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Note: This is now in a project with GIT/SVN support. 161031.

# Motivation


http://www.itl.nist.gov/div898/strd/nls/nls_info.shtml presents a number of nonlinear
regression (nonlinear least squares) problems that are more or less difficult to solve
numerically. Doug Bates prepared an **R** package `NISTnls` which adapted these problems
to **R** and tested them with the `nls()` function of which he was a major author.
I built a related package to allow the same problems to be approached as unconstrained function 
minimization problems, which I named `NISTopt`. However, this package was, when I prepared
it in 2009, incomplete, particularly in respect to the manuals (Rd files). This vignette
is an attempt to better document that effort and in the process force a review of the
package. Furthermore, it raises the question of how to **efficiently** add and run
new test problems. 

Note that the problems here are **NOT** always good illustrations of tasks to 
which the various
function minimization tools should be applied. However, they do suggest limits 
of performance of these tools. 

In **R** circles, function minimization
is often called "optimization", though that generally implies that there
are also constraints. 

# Approach and review of a previous effort

We need to be able to set things up so that a separate command is not needed for each start
or example. Such a structure needs a lot of careful thought to 
avoid awkwardness. In particular,
the existing trial (from 2008/9) of package `NISTopt` shows that its structure has a lot of
code, much of which is common in nature. Moreover, we want to be able to add new problems 
easily. Furthermore the "Name.setup" functions do not seem very helpful for the long term.

## Restrictions on the problems

We do not wish (at the moment) to 
include general optimization problems with general constraints.
In fact, we will limit our attention to at most bounds constrained nonlinear optimization and
nonlinear least squares problems. There are, however, a lot of 
these. By considering lower and
upper bounds that are equal, we can extend the constraints to fixed or **masked** parameters.

# Design I

We may be willing to have a single file to describe a single (but more or less complete)
problem, but we ultimately want
a **set** of problems, all of which can be accessed through a single structure. Through 
some experiments, detailed in *Appendix A: Use of a data frame*, we find that one could,
if desired, store the problems in a data frame. Other structures are, of course, 
equally possible. 

Using a data frame may, however, be overly complex. With suitable tools, one should be
able to easily create and manipulate the objects created in the 
flat (i.e., plain text) file of a single problem. 

This design is not, of course, the only possibility. However, it is likely that something
based on the "single problem" **R** code file illustrated in the next section will prove
useful.

## A single problem

Let us consider how we might, in **R**, specify a nonlinear least squares problem that
also can be presented as an optimization problem. Here is a possible file for the 
problem of @danwood1980.

```{r cache=FALSE, echo=FALSE}
require(knitr)
# read chunk (does not run code)
read_chunk('../inst/extdata/DanielWood.prb')
```

```{r}
<<DanielWood.prb>>
```

## Tools for preparing and using problem files

### Access to files

In order to use problem files, we need a way to list them, display their content in
both summary and detail, and attempt to use them with various nonlinear least squares
and/or function minimization software.

#### Command line file lister and display tool

We need a tool that 

- sets the directory where problems are found

- lists the files

- allows one file to be selected

- displays information in a structured way (possibly according to some profile)

- allows the profile for display to be edited somehow

?? code here

#### GUI file lister and display tool

Likely tied into command line tool by allowing command line to be executed when
mouse or pointer clicks are executed. Check existing GUI tools to see what is 
possible.

?? code here

### Building problem files

#### Data frame or matrix to source vector

If problem files are to be self contained, we do not want to need to access external
files. The simplest way to present a variable to **R** is to input data as a simple
list and then name it. To prepare the problem file, we therefore want to be able to
get data into the local **R** environment and prepare the text for an assignment
statement that contains a source vector.

?? code

```{r, eval=FALSE}

# Use paste() to build the c(...) structure

```


## Running problems

`runoptprob` -- ?? how it should be used

- provide 

    -- filename (at least the root)

    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)

    -- choice of gradient function or approximation (gr= (gr, "grfwd", etc.)) ?? optional?

    -- controls -- as per the control list in programs

    -- other arguments ?? how to provide? dotargs as below?

    -- xdata or dotargs (how to specify might be interesting)
    
    -- timing control (e.g., microbenchmark or simple timing)

- read output control profile (initially just use sink())

- read the file and execute it (make sure it has **R** commands so we can
actually source() it)

- analyze the call to runprob and do the appropriate call

- format output and extract and store summaries

  -- this may be multilayerd and take a lot of work
  
  -- start with no formatting, and gradually add features
  
  -- need to save conditions
  
  -- make sure we have time/date stamp on all runs
  
Issues to address?? :
 - sink() will save information, but there is a cost in time and space
 - how to do ok/not or red/yellow/green nicely | Do we want on params and value?
 - dealing with multiple solutions -- linear combination defined
 - where to put setting of FUZZ, reporting of deviations
  

```{r cache=FALSE, echo=FALSE}
require(knitr)
# read chunk (does not run code)
read_chunk('../R/runoptprob.R')
```

```{r}
<<../R/runoptprob.R>>
  
```{r}  
    runoptprob <- function(pfilename=NULL, minmeth='nls', submeth=NULL, 
                       nstart = 0, options=list(args=NULL, control=NULL) ) {
  #- ?? Need to eval(parse()) ALL functions available, since f calls res etc.
  #- Need to carefully ensure these exist to avoid errors??
  #- ?? can we simplify and NOT have to eval(parse()) them, but simply source the prb file?
  
  print(options$args)
  print(options$controls)
  optecho <- TRUE # temporarily at least, or put in a profile
  #- Get the path to the files (where should these be? Probably somehow related to pkg)   
  pfile <- paste(pfilename, ".prb", sep='')
  source(pfile, echo=optecho) # -- filename (at least the root)
  #- now have a lot of the information
  
  #-    -- which tool to use (optimr, nls, nlmrt, nlsr tools, minpack.LM tools)
  
  #-    -- choice of gradient function or approximation (gr= (gr, "grfwd", etc.))
  
  #-    -- controls -- as per the control list in programs
  
  #-    -- other arguments
  
  #-    -- xdata or dotargs (how to specify might be interesting)
  
  #-    -- timing control (e.g., microbenchmark or simple timing)
  
  #-  - read output control profile (initially just use sink())
  #-  -- make sure we have time/date stamp on all runs
  fname<-paste(pfilename, format(Sys.time(), "%Y%m%d%H%M"),".out",sep='')
  sink(fname, append=TRUE, split=TRUE)
  
  #-  - read the file and execute it (make sure it has **R** commands so we can
  #-   actually source() it)
  #- ?? not needed eval(parse(text=paste(pfilename,".setup", sep=''))) #- setup function
  #- get the data and the starts
  dfname <- eval(parse(text=paste(pfilename,".df", sep='')))
  print(dfname)
  
  #- - analyze the call to runprob and do the appropriate call
  
  #- - format output and extract and store summaries
  
  #-  -- this may be multilayerd and take a lot of work
  
  #-  -- start with no formatting, and gradually add features
  
  #-  -- need to save conditions
  if (nstart == 0) { # need to loop
    nst <- seq(1: dim(starts)[1])
  } else { nst <- nstart }
  if (minmeth == 'nls') {
    for (istrt in nst){
      #- ?? need to extract options and arguments like trace
      #- some documentation output needed ??
      sol <- nls(mformula, data=dfname, start=starts[istrt,], trace=TRUE)      
      print(sol)
      print(summary(sol))
    }    
  }  
  if (minmeth == 'nlxb') {
      require(nlmrt)
      for (istrt in nst){
      #- ?? need to extract options and arguments like trace
      #- some documentation output needed ??
      sol <- nlxb(mformula, data=dfname, start=starts[istrt,], trace=TRUE)      
      print(sol)
      print(summary(sol))
    }    
  }  
  if (minmeth == "optimr") {
     require(optimrx)
    #- here need to check if they exist??
     ufn <- eval(parse(text=paste(pfilename,".f", sep='')))
     eval(parse(text=paste(pfilename,".res", sep='')))
     eval(parse(text=paste(pfilename,".jac", sep='')))
     eval(parse(text=paste(pfilename,".g", sep='')))
     if( is.null(options$args[["gr"]]) || ! is.character(options$args[["gr"]]) ) {
       #- name.gr now a function      
       ugr <- eval(parse(text=paste(pfilename,".g", sep='')))
     } else { ugr <- (options$args[["gr"]]) }
     ufn <-  eval(parse(text=paste(pfilename,".f", sep='')))
     for (istrt in nst){
        sol <- optimr(starts[istrt,], ufn, ugr, method=submeth, control=list(trace=1))
        print(sol)
     }
  }
    #- result should be a list of things run
  sink()
  testsol <- list(pfilename=pfilename, nstart=nstart, minmeth=minmeth, submeth=submeth)
}
```

## Running multiple problems

- prepare "problem list", like a play list

- run them in sequence

- try to figure out how to save the output 
    
    -- sink
    
    -- summaries
    
    -- test against expected output
    
    -- timings
    
    -- measures of success


For the moment, let us just call runoptprob(). Note that it creates a sinkfile for each
call.

```{r}
pfname <- "DanielWood"
# try it
test1 <- runoptprob(pfilename=pfname, minmeth="nls")
test1
tmp <- readline("continue")

test2 <- runoptprob(pfilename=pfname, minmeth="nlxb")
test2
tmp <- readline("continue")

test3 <- runoptprob(pfilename=pfname, minmeth="optimr", submeth="L-BFGS-B")
test3
```
## Appendix A: Use of a data frame

The following script shows that we can store problem materials, including functions,
**INSIDE** an **R** data frame.

```{r, eval=FALSE}
require(NISTO)
ls(package:NISTO)
NISTO::DanielWood.res
NISTO:::DanielWood.res
f1 <- y ~ (b1+x*(b2+x*(b3+b4*x))) / (1+x*(b5+x*(b6+x*b7)))
str(f1)
?NISTO
?DanielWood
data(DanielWood)
DanielWood
dwprob <- list(mform = f1, mdata=DanielWood, pname="DanielWood", ptype="nls")
dwprob
data()
f2 <- y ~ b1 / (1+exp(b2-b3*x))
r2data <-Ratkowsky2
r2data
r2prob <- list(mform = f2, mdata=Ratkowsky2, pname="Ratkowsky2", ptype="nls")
r2prob
myprobs <- rbind(dwprob, r2prob)
myprobs
str(myprobs)
myprobs.d <- as.data.frame(myprobs)
str(myprobs.d)
f3 <- y ~ exp(-b1*x)/(b2+b3*x)
c1data <- Chwirut1
c1name <- "Chwirut1"
c1prob <- list(mform = f3, mdata=Chwirut1, pname=c1name, ptype="nls")
myprobs.d[3,] <- c1prob
myprobs.d <- as.dataframe(rbind(myprobs.d, c1prob))
myprobs.d <- as.data.frame(rbind(myprobs.d, c1prob))
myprobs.d <- as.data.frame(rbind(myprobs, c1prob))
myprobs.d
str(myprobs.d)
myprobs.d[,5] <- NA
str(myprobs.d)
colnames(myprobs.d[,5] <- "resfn")
colnames(myprobs.d[,5]) <- "resfn"
colnames(myprobs.d)[5] <- "resfn"
myprobs.d
DanielWood.res <- function(b) {
   xx<-DanielWood$x # case !!
   yy<-DanielWood$y
   res <- rep(NA, length(xx))
   b1<-b[1]
   b2<-b[2]
   res<-b1*(xx**b2) - yy
   return(res)
}
myprobs.d[1,5] <- DanielWood.res
myprobs.d[1,5] <- quote(DanielWood.res)
dwreschr <- "DanielWood.res <- function(b) {;xx<-DanielWood$x; yy<-DanielWood$y; res <- rep(NA, length(xx)); b1<-b[1];  b2<-b[2];   res<-b1*(xx**b2) - yy;   return(res);}"
myprobs.d[1,5] <- dwreschr
ls()
rm DanielWood.res
rm( DanielWood.res)
ls
ls()
source("myprobs.d[1,5])
"
)
source("myprobs.d[1,5]")
source(text="myprobs.d[1,5]")
?source
parse(text=myprobs.d[1,5])
ls()
eval(parse(text=myprobs.d[1,5]))
ls()
savehistory("NISTOx1.txt")
```

```{r, eval=FALSE}
# NISTOx2.txt
test <- "
# Chwirut1 - Jacobian
Chwirut1.jac <- function(b) {
   xx<-Chwirut1$x
   yy<-Chwirut1$y
   n<-length(b)
   m<-length(xx)
   b1<-b[1]
   b2<-b[2]
   b3<-b[3]
   J<-matrix(0,m,n) # define the size of the Jacobian
   expr3 <- exp(-b1 * xx)
   expr5 <- b2 + b3 * xx
   expr7 <- expr3 * xx
   expr10 <- expr5*expr5
   value <- expr3/expr5
   J[,1] <- -(expr7/expr5)
   J[,2] <- -(expr3/expr10)
   J[,3] <- -(expr7/expr10)
   return(J)
}
"
ftest <- eval(parse(test))
ftest <- eval(parse(text=test))
bstart <- c(1,1,1)
print(ftest(bstart))
savehistory("NISTOx2.txt")
```