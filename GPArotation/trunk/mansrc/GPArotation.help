
\name{GPA}
\alias{GPForth}
\alias{GPFoblq}

\title{Rotation optimization}
\usage{
    GPForth(A, Tmat=diag(ncol(A)), method="varimax", normalize=FALSE, eps=1e-8, maxit=1000, ...)
    GPFoblq(A, Tmat=diag(ncol(A)), method="quartimin", normalize=FALSE, eps=1e-8, maxit=1000, ...)
    }
\arguments{
    \item{A}{initial factor loadings matrix for which the rotation 
             criterian is to be optimized.}
    \item{Tmat}{initial rotation matrix.}
    \item{method}{rotation objective criterian.}
    \item{normalize}{see details.}
    \item{eps}{convergence is assumed when the norm of the gradient is smaller
         than eps.}
    \item{maxit}{maximum number of iterations allowed in the main loop.}
    \item{...}{additional arguments passed to the rotation objective}
}

\description{
   Gradient projection rotation optimization routine used by various rotation
   objective.
   }
\value{A list with elements 
  \item{Lh}{The rotated loadings, one column for each factor.}
  \item{Th}{The rotation matrix.}
  \item{Table}{A matrix recording the iterations of the rotation optimization.}
  \item{method}{A string indicating the rotation objective function.}
  \item{orthogonal}{A logical indicating if the rotation is orthogonal.}
  \item{convergence}{A logical indicating if convergence was obtained.}
  \item{Phi}{t(Th) \%*\% Th.  This will be the identity matrix for orthogonal
  rotations so is omitted from the result of GPForth.}
  }
\details{
 Gradient projection rotation optimization routines developed by
 Coen A. Bernaards and Robert I. Jennrich. These functions can be used directly
 to rotate a loadings matrix, or indirectly through a rotation
 objective passed to a factor estimation routine such as \code{\link{factanal}}.
 For examples of the indirect use see the documention for 
 rotations (such as \code{\link{oblimin}}).

 GPForth is the main GP algorithm for orthogonal rotation.
 GPFoblq is the main GP algorithm for oblique rotation.
 Both algorithms require a loadings matrix \code{A} and optionally 
 an initial rotation matrix \code{Tmat} indicating any rotation that has already
 been performed. (These together fix the equivalence class over which the optimization
 is done.) By default the initial rotation is the identity matrix.
 
 The argument \code{method} can be used to specify a string indicating
 the rotation objective. \code{GPFoblq} defaults to \code{"quartimin"} 
 and \code{GPForth} defaults to \code{"varimax"}. Available rotation objectives
 are "oblimin", "quartimin", "target", "pst", "oblimax", "entropy", 
 "quartimax", "varimax", "simplimax", "bentler", "tandemI", "tandemII", 
 "geomin", "cf", "infomax" and "mccammon". The string is prefixed with 
 "vgQ." to give the actual function call. The \code{vgQ.*} function call
 would typically not be used directly, so these methods are not exported
 from the package namespace. You can print these functions to see the code for
 calculating a criterion, but since they are not exported the package 
 name needs to be specified. For example, use
 \code{GPArotation:::vgQ.oblimin} to view the function \code{vgQ.oblimin}.

 Some rotation criteria (including \code{simplimax}, \code{pst}, 
 \code{procrustes})
 require one or more additional arguments. For example, \code{simplimax}
 needs the number of 'close to zero loadings' which is given  as
 the extra argument \code{k}. Check the rotation methods for details. 
 (If a new rotation method is implemented and needs additional
 arguments then this is the  way to pass them.)

 The argument \code{normalize} gives an indication of if and how any
 normalization should be done before rotation, and then undone after rotation.
 If \code{normalize} is \code{FALSE} (the default) no normalization is done.
 If \code{normalize} is \code{TRUE} then Kaiser normalization is done. (So
 squared row entries of normalized \code{A} sum to 1.0.)
 If \code{normalize} is a vector of length equal to the number of indicators (=
 number of rows of \code{A}) then the colums are divided by \code{normalize} 
 before rotation and multiplied by \code{normalize} after rotation. 
 If \code{normalize} is a matrix of the same dimension as \code{A} then \code{A}
 is divided by \code{normalize} before rotation and multiplied 
 by \code{normalize} after rotation. 
 If \code{normalize} is a function then it should take \code{A} as an argument
 and return a matrix which is used like the matrix above. 
}
\seealso{
   \code{\link{Random.Start}}
   \code{\link[stats]{factanal}}
   \code{\link{oblimin}}
   \code{\link{quartimin}}
   \code{\link{targetT}}
   \code{\link{targetQ}}
   \code{\link{pstT}}
   \code{\link{pstQ}}
   \code{\link{oblimax}}
   \code{\link{entropy}}
   \code{\link{quartimax}}
   \code{\link{Varimax}}
   \code{\link[stats]{varimax}}
   \code{\link{simplimax}}
   \code{\link{bentlerT}}
   \code{\link{bentlerQ}}
   \code{\link{tandemI}}
   \code{\link{tandemII}}
   \code{\link{geominT}}
   \code{\link{geominQ}}
   \code{\link{cfT}}
   \code{\link{cfQ}}
   \code{\link{infomaxT}}
   \code{\link{infomaxQ}}
   \code{\link{mccammon}}
   \code{\link[stats]{promax}}
}
\examples{
  data("Harman", package="GPArotation")
  qHarman  <- GPForth(Harman8, Tmat=diag(2), method="quartimax")
  }
\author{Coen A. Bernaards and Robert I. Jennrich
        with some R modifications by Paul Gilbert}
\source{code is modified from original source splusfunctions.net available at 
  \url{http://www.stat.ucla.edu/research/gpa}.
}
\reference{
   source{\url{http://www.stat.ucla.edu/research} or
          \url{http://www.stat.ucla.edu/research/gpa}
   }
   The software reference is

   Bernaards, C.A. and Jennrich, R.I. (in press) Gradient Projection 
     Algorithms and Software for Arbitrary Rotation Criteria in Factor
     Analysis. Educational and Psychological Measurement.

   Theory of gradient projection algorithms may be found in:

   Jennrich, R.I. (2001). A simple general procedure for orthogonal rotation.
       Psychometrika, 66, 289-306.

   Jennrich, R.I. (2002). A simple general method for oblique rotation. 
       Psychometrika, 67, 7-19.
   }
\concept{rotation}
\keyword{multivariate}

\name{Random.Start}
\alias{Random.Start}

\title{Generate a Random Orthogonal Rotation}
\usage{
    Random.Start(k)
    }
\arguments{
    \item{k}{An integer indicating the dimension of the square matrix.}
    }

\description{
   Random orthogonal rotation to use as Tmat matrix to start GPForth or GPFoblq.
   }
\value{An orthogonal matrix.}

\details{
  The random start function produces an orthogonal matrix with columns
  of length one based on the QR decompostion.
  }
\seealso{
   \code{\link{GPForth}}
   \code{\link{GPFoblq}}
   \code{\link{oblimin}}
   }
\examples{
   Global.min <- function(A,method,B=10){
      fv <- rep(0,B)
      seeds <- sample(1e+7, B)
      for(i in 1:B){
    	cat(i," ")
    	set.seed(seeds[i])
    	gpout <- GPFoblq(A=A, Random.Start(ncol(A)), method=method)
    	dtab <- dim(gpout$Table)
    	fv[i] <- gpout$Table[dtab[1],2]
    	cat(fv[i], "\n")
      }
      cat("Min is ",min(fv),"\n")
      set.seed(seeds[order(fv)[1]])
      ans <- GPFoblq(A=A, Random.Start(ncol(A)), method=method)
      ans
      }

   data("Thurstone", package="GPArotation")

   Global.min(box26,"simplimax",10)
   }
\author{Coen A. Bernaards and Robert I. Jennrich
        with some R modifications by Paul Gilbert
	}
\concept{rotation}
\keyword{multivariate}


\name{rotations}
\alias{oblimin}
\alias{quartimin}
\alias{targetT}
\alias{targetQ}
\alias{pstT}
\alias{pstQ}
\alias{oblimax}
\alias{entropy}
\alias{quartimax}
\alias{Varimax}
\alias{simplimax}
\alias{bentlerT}
\alias{bentlerQ}
\alias{tandemI}
\alias{tandemII}
\alias{geominT}
\alias{geominQ}
\alias{cfT}
\alias{cfQ}
\alias{infomaxT}
\alias{infomaxQ}
\alias{mccammon}

\alias{vgQ.oblimin}
\alias{vgQ.quartimin}
\alias{vgQ.target}
\alias{vgQ.pst}
\alias{vgQ.oblimax}
\alias{vgQ.entropy}
\alias{vgQ.quartimax}
\alias{vgQ.varimax}
\alias{vgQ.simplimax}
\alias{vgQ.bentler}
\alias{vgQ.tandemI}
\alias{vgQ.tandemII}
\alias{vgQ.geomin}
\alias{vgQ.cf}
\alias{vgQ.infomax}
\alias{vgQ.mccammon}

\title{Rotations}
\usage{
    oblimin(L, Tmat=diag(ncol(L)), gam=0, normalize=FALSE, eps=1e-8, maxit=1000)
    quartimin(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    targetT(L, Tmat=diag(ncol(L)), Target=NULL, normalize=FALSE, eps=1e-8, maxit=1000)
    targetQ(L, Tmat=diag(ncol(L)), Target=NULL, normalize=FALSE, eps=1e-8, maxit=1000)
    pstT(L, Tmat=diag(ncol(L)), W, Target=NULL, normalize=FALSE, eps=1e-8, maxit=1000)
    pstQ(L, Tmat=diag(ncol(L)), W, Target=NULL, normalize=FALSE, eps=1e-8, maxit=1000)
    oblimax(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    entropy(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    quartimax(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    Varimax(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    simplimax(L, Tmat=diag(ncol(L)), k=nrow(L), normalize=FALSE, eps=1e-8, maxit=1000)
    bentlerT(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    bentlerQ(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    tandemI(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    tandemII(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    geominT(L, Tmat=diag(ncol(L)), delta=.01, normalize=FALSE, eps=1e-8, maxit=1000)
    geominQ(L, Tmat=diag(ncol(L)), delta=.01, normalize=FALSE, eps=1e-8, maxit=1000)
    cfT(L, Tmat=diag(ncol(L)), kappa=0, normalize=FALSE, eps=1e-8, maxit=1000)
    cfQ(L, Tmat=diag(ncol(L)), kappa=0, normalize=FALSE, eps=1e-8, maxit=1000)
    infomaxT(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    infomaxQ(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)
    mccammon(L, Tmat=diag(ncol(L)), normalize=FALSE, eps=1e-8, maxit=1000)

    vgQ.oblimin(L, gam=0)
    vgQ.quartimin(L)
    vgQ.target(L, Target=NULL)
    vgQ.pst(L, W, Target=NULL)
    vgQ.oblimax(L)
    vgQ.entropy(L)
    vgQ.quartimax(L)
    vgQ.varimax(L)
    vgQ.simplimax(L, k=nrow(L))
    vgQ.bentler(L)
    vgQ.tandemI(L)
    vgQ.tandemII(L)
    vgQ.geomin(L, delta=.01)
    vgQ.cf(L, kappa=0)
    vgQ.infomax(L)
    vgQ.mccammon(L)
}
\arguments{
    \item{L}{a factor loading matrix}
    \item{Tmat}{initial rotation matrix.}
    \item{gam}{0=Quartimin, .5=Biquartimin, 1=Covarimin.}
    \item{Target}{rotation target for objective calculation.}
    \item{W}{weighting of each element in target.}
    \item{k}{number of close to zero loadings.}
    \item{delta}{constant added to L\^2 in objective calculation.}
    \item{kappa}{0=Quartimax, 1/p=Varimax, m/(2*p)=Equamax,
        (m-1)/(p+m-2)=Parsimax, 1=Factor parsimony.}
    \item{normalize}{parameter passed to optimization routine (GPForth or GPFoblq).}
    \item{eps}{parameter passed to optimization routine (GPForth or GPFoblq).}
    \item{maxit}{parameter passed to optimization routine (GPForth or GPFoblq).}
}

\value{A list as needed by \code{factanal} with elements
   \item{loadings}{Lh from \code{GPForth} or \code{GPFoblq}.} 
   \item{rotmat}{Th from \code{GPForth} or \code{GPFoblq}.}  
   \item{Table}{Table from \code{GPForth} or \code{GPFoblq}.}
   \item{logical}{Convergence indicator from \code{GPForth} or \code{GPFoblq}.}
   }
\description{
   Optimize factor loading rotation objective.
}
\details{
 These functions optimize a rotation objective. They can be used directly or the
 function name can be passed to factor analysis functions like \code{factanal}.
 Several of the function names end in T or Q, which indicates if they are
 orthogonal or oblique rotations (called from \code{GPForth} or \code{GPFoblq}
 respectively.  

 The \code{vgQ.*} versions of the code are called by the optimization routine and
 would typically not be used directly, so these methods are not exported
 from the package namespace. (They simply return the function value and gradient
 for a given rotation matrix.) You can print these functions but the package 
 name needs to be specified, since they are not exported. For example, use
 \code{GPArotation:::vgQ.oblimin} to view the function \code{vgQ.oblimin}.
 The T or Q ending on function names should be omitted for the \code{vgQ.*} 
 versions of the code so, for example, use \code{GPArotation:::vgQ.target} to view the target
 criterion calculation.
   
 Rotations which are available are 
\tabular{lll}{

 oblimin   \tab oblique    \tab  oblimin family 			\cr
 quartimin \tab oblique	   \tab         				\cr
 targetT   \tab orthogonal \tab  target rotation			\cr
 targetQ   \tab oblique    \tab  target rotation			\cr
 pstT	   \tab orthogonal \tab  partially specified target rotation	\cr
 pstQ	   \tab oblique    \tab  partially specified target rotation	\cr
 oblimax   \tab oblique	   \tab         				\cr
 entropy   \tab orthogonal \tab  minimum entropy			\cr
 quartimax \tab orthogonal \tab 					\cr
 varimax   \tab orthogonal \tab 					\cr
 simplimax \tab oblique	   \tab         				\cr
 bentlerT  \tab orthogonal \tab  Bentler's invariant pattern simplicity criterion\cr
 bentlerQ  \tab oblique    \tab  Bentler's invariant pattern simplicity criterion\cr
 tandemI   \tab orthogonal \tab  Tandem Criterion, Comrey, 1967 		 \cr
 tandemII  \tab orthogonal \tab  Tandem Criterion, Comrey, 1967 		 \cr
 geominT   \tab orthogonal \tab 					 \cr
 geominQ   \tab oblique	   \tab         				 \cr
 cfT	   \tab orthogonal \tab  Crawford-Ferguson family		 \cr
 cfQ	   \tab oblique	   \tab  Crawford-Ferguson family		 \cr
 infomaxT  \tab orthogonal \tab 					 \cr
 infomaxQ  \tab oblique	   \tab         				 \cr
 mccammon  \tab orthogonal \tab  McCammon minimum entropy ratio 	 \cr
}
 Note that \code{Varimax} defined here uses \code{vgQ.varimax} and 
 is not \code{varimax}
 defined in the \code{stats} package. \code{stats:::varimax} does Kaiser 
 normalization by default whereas \code{Varimax} defined here does not.
 
 New rotation methods can be programmed with a name "vgQ.newmethod". The 
 inputs are the matrix L, and optionally any additional arguments. The
 output should be a list with elements 
\tabular{ll}{
  \code{f}       \tab the value of the criterion at L.\cr
  \code{Gq}      \tab the gradient at L.\cr
  \code{Method}  \tab a string indicating the criterion.\cr
 }
 }
\examples{
  data(ability.cov)
  factanal(factors = 2, covmat = ability.cov, rotation="oblimin")

  data("Harman", package="GPArotation")
  qHarman  <- GPForth(Harman8, Tmat=diag(2), method="quartimax")
  qHarman2 <- quartimax(Harman8) 

  data("WansbeekMeijer", package="GPArotation")
  unrotated  <- factanal(factors = 2, covmat=NetherlandsTV, rotation="none")
  unrotated
  GPForth(loadings(unrotated), Tmat=diag(2), method="varimax")$Lh
  factanal(factors = 2, covmat=NetherlandsTV, rotation="Varimax")
  factanal(factors = 2, covmat=NetherlandsTV, rotation="varimax")
  GPFoblq(loadings(unrotated), Tmat=diag(2), method="oblimin")$Lh
  }
\seealso{
   \code{\link{GPForth}}
   \code{\link{GPFoblq}}
   \code{\link[stats]{factanal}}
   \code{\link[stats]{varimax}}
   \code{\link[stats]{promax}}
}
\reference{
   source{\url{http://www.stat.ucla.edu/research} or
          \url{http://www.stat.ucla.edu/research/gpa}
   }
   The software reference is

   Bernaards, C.A. and Jennrich, R.I. (in press) Gradient Projection 
     Algorithms and Software for Arbitrary Rotation Criteria in Factor
     Analysis. Educational and Psychological Measurement.

   A discussion of rotation objectives can be found in many references,
   for example, Tom Wansbeek and Erik Meijer (2000) Measurement 
   Error and Latent Variables in Econometrics, North-Holland: Amsterdam
  }

\author{Coen A. Bernaards and Robert I. Jennrich
        with some R modifications by Paul Gilbert.}
\concept{rotation}
\keyword{multivariate}


\name{NormalizingWeight}
\alias{NormalizingWeight}

\title{Internal Utility for Normalizing Weights}
\usage{
    NormalizingWeight(A, normalize=FALSE)
    }
\arguments{
    \item{A}{A loading matrix.}
    \item{normalize}{An indication of if/how the matrix should be normalized.}
}

\description{
   See GPFobliq and GPForth.
   }
\value{A matrix.}

\keyword{internal}

