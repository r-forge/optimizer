Done:  Top MOST recent

150730: - fixup calls to several optimizers
	- test hobbs15b
150728: - optim() -- bounds method!
        - Fix coef extraction.!! / summary method
        - Fix problem with very simple function sum(x*x) and numerical gradient
150724: - got kktchk going, and integrated more or less into opm, but issue of kkt1 and 
	  kkt2 NOT logical in result. Probably matrix is numeric.
150723: - add CITATION file to inst/ directory
        - add kktc and manual, but not test / example
        - Do not allow fn, numerical gr, analytic hess calls.
        - Got optchk running, with example
150721: - opm sort of working. Need to tidy output and ensure tested
	- bounds tested with optimr
150714: - got optimr working with scaling by putting efn, egr INSIDE optimr and using spar
	and pscale and fnscale defined at top. Arguments are ORIGINAL par and fn and gr. No
	hess at this point. Not are quoted grad routines available yet.R
150710: - need to adjust bounds for parscale	
	- the optest function more or less works. We can create the cfg using setup, and
	  the scaled fn and gr work fine in optim() and Rvmmin and Rcgmin with minor setup
	  issues. BUT running in optest seems to fail for Rcgmin (did not try Rvmmin, but 
	  suspect also)
	  Got op working -- but not tested for bounds. But failed later when scaling.
150709: - optimr -- need to sort out counts for methods


--------------------------------------------------------------------------------------------

Top LEAST recent

150708:

- problems with saving to ans.ret[meth, ] for single method. Need to fix
- Note that trace > 0 does not seem to be transferred to optim
  In fact, fn and gr are seemingly not transferred correctly. Something seriously wrong.

150709:

- setup of ufn, ugr -- worked using optest package. Found it too easy to make mistakes.
- optimr: a replacement for optim that returns single method output with hessian NULL.
   This should allow optimx to be a loop wrapper and call this using ufn and ugr so we
   avoid lots of the internal stuff (though the overhead will still be there in general).
- Note lots of ?? re Imports and Namespace. Need to learn this better.
- optimr -- parameter scaling
  How: spar <- par / pscale    Scaled parameters (over which we optimize)

       par <- spar*pscale      Unscaled parameters

       sfn(spar, ...) = fn(par, ...) = fn(spar*pscale, ...)

       How do we communicate the pscale  (= control$parscale for optim)

       Maybe use control$parscale and default it to rep(1, npar)

150710: 

- optest.check seems to fail at fnchk, but fnchk works on its own. Weird.

150711: 
- op does not seem to call optimr correctly, but running optest.setup then optimr
works OK.
- config structure should include flag to note that testing has been completed (testsOK)
This would let us run several methods with a single setup.
- the ufn and ugr keep changing environment labels. And get msg that formal
argument 'pscale' matched by multiple actual arguments. 
- problem may be that the structure gets built again and again. WHy?

150712:
- tried deleting mycfg etc. No joy. Can get optim and optimr to run from command line, but op
	gets "formal argument 'pscale' matched by multiple actual arguments"
  Found an item about this problem, which used write.csv as example

	write.csv <- function (...)
	{
	Call <- match.call(expand.dots = TRUE)
	for (argname in c("append", "col.names", "sep", "dec", "qmethod"))
	if (!is.null(Call[[argname]]))
	warning(gettextf("attempt to set '%s' ignored", argname), domain = NA)
	rn <- eval.parent(Call$row.names)
	Call$append <- NULL
	Call$col.names <- if (is.logical(rn) && !rn) TRUE else NA
	Call$sep <- ","
	Call$dec <- "."
	Call$qmethod <- "double"
	Call[[1L]] <- as.name("write.table")
	eval.parent(Call)
	}

The idea is to prevent R from using the wrong argument to a function. So how to use this for my
op problem?

150714: 
- From reading Hadley's "Advanced R" about environments, converted optcfg to environment, and made
the parent the emptyenv() (to avoid having any objects defined in it other than those specified).
Now can run optim, but not optimr. Check to see why. Seems to be something related to NOT having
explicit scaling inside optimr, but relying on dots. ?? Try to make optimr ALWAYS refer to the
scaling, maybe using the control$parscale. That is, put the scaling INSIDE optimr and not in
the setup.
- NEW TRY: use ONLY the original parameters and functions, and do all the fixup inside optimr
- optimr will be for a SINGLE method and it will use the openv environment. It's arguments could be
    method (but that could be in the environment) and possibly a control list, but again this is
    better placed in the environment, which is where we modify things.
- use control$parscale and control$fnscale. 
- Do we want to allow optimr() to have same args as optim, but more optimizers. That would be nice,
  but possibly inefficient, though it avoids the environment of setup. However, it could be more sensible
  in the long run, and avoids setup AND the special openv environment. 
- started adding numerical gradient approximations. Note that egr is built even when the method
  does not require a gradient

150723: - kktc added, but there is no test yet
        - need to sort out maximize / fnscale to make sure they are consistent
        - check that numerical derivatives work
        - allow  control$defgrapprox NULL or NA to stop() when trying a gradient method. i.e., 
	  we can specify NO gradient approximation ???
        -   # ?? need to apply constraints to gradient and hessian
        -   # ?? check for no free parameters
        -   # ?? provide both free parameter and constrained parameter gradient and Hessian measures??

150728: - ?? need to check egr in optimr, esp when gr is character and parscale not 1
        - optim() methods -- issue with fn and gr -- watch out that gr is replaced if not careful

