---
title: "nlsr Derivatives"
author: "John C. Nash"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: nlpd.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

This vignette is an attempt to catalog and illustrate the various 
capabilities in the **R** statstical computing system to 
perform differentiation. There are many traps and pitfalls for
the unwary in doing this, and it is hoped that this rather
long treatment will serve to record these and show how to avoid
them, and how to reliably compute the derivatives desired.
Derivative capabilities of **R** are in the base system (essentially
the functions `D()` and `deriv()`) and in
different packages, namely `nlsr`, `Deriv`, `Ryacas`. General tools for
approximations to derivatives are found in the package `numDeriv` as
well as `optextras`. Particular approximations may be embedded in 
various packages, but not necessarily exported for use in scripts
or packages.

As a way of recording where attention is needed either to this document
or to the functions and methods describle, I have put double question marks
in various places.


## TODOS 

??

## Available analytic differentiation tools

**R** has a number of tools for finding analytic derivatives.

- **stats**: tools `D()` and `deriv()`

- **nlsr**: tools ??

- **Deriv**: tools ??

- **Ryacas**: tools ??

- ?? any others

## How the tools are used

This is an overview section to give an idea of the capabilities. It is
not intended to be exhaustive, but to give pointers to how the tools can
be used quickly.

### stats

`D()`, `deriv()` and `deriv3()`. As `deriv3()` is stated to be the same as `deriv()` but with
argument `hessian=TRUE`, we will for now only consider the first two.

```{r}

dx2x <- deriv(~ x^2, "x") 
dx2x
mode(dx2x)
str(dx2x)
x <- -1:2
eval(dx2x) # This is evaluated at -1, 0, 1, 2, with the result in the "gradient" attribute
# Note that we cannot (easily) differentiate this again.
firstd <- attr(dx2x,"gradient")
str(firstd)
d2x2x <- try(deriv(firstd, "x"))
str(d2x2x)
#- Build a function from the expression
fdx2x<-function(x){eval(dx2x)}
fdx2x(1)
fdx2x(3.21)
fdx2x(1:5)
#- # Now try D()
Dx2x <- D(expression(x^2), "x")
Dx2x
x <- -1:2
eval(Dx2x)
# We can differentiate aggain
D2x2x <- D(Dx2x,"x")
D2x2x
eval(D2x2x) #- But we don't get a vector -- could be an issue in gradients/Jacobians
#- Note how we handle an expression stored in a string via parse(text=  ))
sx2 <- "x^2"
sDx2x <- D(parse(text=sx2), "x")
sDx2x
#- But watch out! The following "seems" to work, but the answer is not as intended
Dx2xx <- D((x^2), "x")
Dx2xx
eval(Dx2xx)
#-  Something 'tougher':
trig.exp <- expression(sin(cos(x + y^2)))
( D.sc <- D(trig.exp, "x") )
all.equal(D(trig.exp[[1]], "x"), D.sc)
( dxy <- deriv(trig.exp, c("x", "y")) )
y <- 1
eval(dxy)
eval(D.sc)
#-  function returned:
deriv((y ~ sin(cos(x) * y)), c("x","y"), func = TRUE)
#- ??#-  Surely there is an error, since docs say no lhs!
#-  function with defaulted arguments:
(fx <- deriv(y ~ b0 + b1 * 2^(-x/th), c("b0", "b1", "th"),
             function(b0, b1, th, x = 1:7){} ) )
fx(2, 3, 4)
#-  First derivative
D(expression(x^2), "x")
#-  stopifnot(D(as.name("x"), "x") == 1) #- A way of testing. How does it work??
#-  Higher derivatives showing deriv3
myd3 <- deriv3(y ~ b0 + b1 * 2^(-x/th), c("b0", "b1", "th"),
     c("b0", "b1", "th", "x") )
myd3(2,3,4, x=1:7)
#- check against deriv()
myd3a <- deriv(y ~ b0 + b1 * 2^(-x/th), c("b0", "b1", "th"),
     c("b0", "b1", "th", "x"), hessian=TRUE )
myd3a(2,3,4, x=1:7)
all.equal(myd3a, myd3) #- Remember to check things!


#-  Higher derivatives:
DD <- function(expr, name, order = 1) {
   if(order < 1) stop("'order' must be >= 1")
   if(order == 1) D(expr, name)
   else DD(D(expr, name), name, order - 1)
}
DD(expression(sin(x^2)), "x", 3)
#-  showing the limits of the internal "simplify()" :
#-  -sin(x^2) * (2 * x) * 2 + ((cos(x^2) * (2 * x) * (2 * x) + sin(x^2) *
#-     2) * (2 * x) + sin(x^2) * (2 * x) * 2)

```

### nlsr

```{r}
require(nlsr)
#- fj <- function(x) {
#-      eval(fnDeriv(parse(text="b0 + b1 * 2^(-x/th)"), c("b0", "b1", "th")) )
#- }
#- fj.1 <- try(fj(x=1, b0=2, b1=3, th=4)) #-  Get errors ???
b0 <- 2
b1 <- 3
th <- 4
#- fj.2 <- try(fj(1))
#- fje <- try(fnDeriv(parse(text="b0 + b1 * 2^(-x/th)"), c("b0", "b1", "th")))
#- str(fje)
x <- 1
#- eval(fje)
#- Need to sort out the above ???


dx2xn <- try(Deriv(~ x^2, "x")) #- Does not work for nlsr
dx2xn <- try(Deriv(x^2, "x")) #- But this does -- the tilde is not used in nlsr::Deriv
dx2xn
mode(dx2xn)
str(dx2xn)
x <- -1:2
eval(dx2xn) # This is evaluated at -1, 0, 1, 2, BUT result is returned directly,
#-  NOT in "gradient" attribute
# Note that we cannot (easily) differentiate this again.
firstd <- dx2xn
str(firstd)
d2x2xn <- try(Deriv(firstd, "x")) #- this APPEARS to work, but WRONG answer ??
str(d2x2xn)
d2x2xn
eval(d2x2xn)
firstde <- quote(firstd)
firstde
firstde <- bquote(firstd)
firstde
Deriv(firstde, "x")
Deriv(2*x, "x")
firstc <- as.call(firstd)
Deriv(firstc, "x")
#- Build a function from the expression
fdx2xn<-function(x){eval(dx2xn)}
fdx2xn(1)
fdx2xn(3.21)
fdx2xn(1:5)
```

The tool `fnDeriv` seems more problematic. ??

```{r}



dx2xnf <- try(fnDeriv(~ x^2, "x")) #- Does not work for nlsr
dx2xnf <- try(fnDeriv(expression(x^2))) #- But this does -- the tilde is not used in nlsr::Deriv
dx2xnf
mode(dx2xnf)
str(dx2xnf)
x <- -1:2
eval(dx2xnf) # This is evaluated at -1, 0, 1, 2, BUT result is returned directly,
#-  NOT in "gradient" attribute
# Note that we cannot (easily) differentiate this again.
firstd <- dx2xnf
str(firstd)
d2x2xnf <- try(Deriv(firstd, "x")) #- this APPEARS to work, but WRONG answer ??
str(d2x2xnf)
d2x2xnf
eval(d2x2xnf)


#- # Now try D()
Dx2x <- D(expression(x^2), "x")
Dx2x
x <- -1:2
eval(Dx2x)
# We can differentiate aggain
D2x2x <- D(Dx2x,"x")
D2x2x
eval(D2x2x) #- But we don't get a vector -- could be an issue in gradients/Jacobians
#- Note how we handle an expression stored in a string via parse(text=  ))
sx2 <- "x^2"
sDx2x <- D(parse(text=sx2), "x")
sDx2x
#- But watch out! The following "seems" to work, but the answer is not as intended
Dx2xx <- D((x^2), "x")
Dx2xx
eval(Dx2xx)
#-  Something 'tougher':
trig.exp <- expression(sin(cos(x + y^2)))
( D.sc <- D(trig.exp, "x") )
all.equal(D(trig.exp[[1]], "x"), D.sc)
( dxy <- deriv(trig.exp, c("x", "y")) )
y <- 1
eval(dxy)
eval(D.sc)
#-  function returned:
deriv((y ~ sin(cos(x) * y)), c("x","y"), func = TRUE)
#- ??#-  Surely there is an error, since docs say no lhs!
#-  function with defaulted arguments:
(fx <- deriv(y ~ b0 + b1 * 2^(-x/th), c("b0", "b1", "th"),
             function(b0, b1, th, x = 1:7){} ) )
fx(2, 3, 4)
#-  First derivative
D(expression(x^2), "x")
#-  stopifnot(D(as.name("x"), "x") == 1) #- A way of testing. How does it work??
#-  Higher derivatives showing deriv3
myd3 <- deriv3(y ~ b0 + b1 * 2^(-x/th), c("b0", "b1", "th"),
     c("b0", "b1", "th", "x") )
myd3(2,3,4, x=1:7)
#- check against deriv()
myd3a <- deriv(y ~ b0 + b1 * 2^(-x/th), c("b0", "b1", "th"),
     c("b0", "b1", "th", "x"), hessian=TRUE )
myd3a(2,3,4, x=1:7)
all.equal(myd3a, myd3) #- Remember to check things!


#-  Higher derivatives:
DD <- function(expr, name, order = 1) {
   if(order < 1) stop("'order' must be >= 1")
   if(order == 1) D(expr, name)
   else DD(D(expr, name), name, order - 1)
}
DD(expression(sin(x^2)), "x", 3)
#-  showing the limits of the internal "simplify()" :
#-  -sin(x^2) * (2 * x) * 2 + ((cos(x^2) * (2 * x) * (2 * x) + sin(x^2) *
#-     2) * (2 * x) + sin(x^2) * (2 * x) * 2)



```


### Deriv

```{r}
require(Deriv)

f <- function(x) x^2
Deriv(f)
# function (x)
# 2 * x

f <- function(x, y) sin(x) * cos(y)
Deriv(f)
# function (x, y)
# c(x = cos(x) * cos(y), y = -(sin(x) * sin(y)))

f_ <- Deriv(f)
f_
f_(3, 4)
#              x         y
# [1,] 0.6471023 0.1068000

Deriv(~ f(x, y^2), "y")
# -(2 * (y * sin(x) * sin(y^2)))

Deriv(quote(f(x, y^2)), c("x", "y"), cache.exp=FALSE)
# c(x = cos(x) * cos(y^2), y = -(2 * (y * sin(x) * sin(y^2))))

Deriv(expression(sin(x^2) * y), "x")
# expression(2 * (x * y * cos(x^2)))

Deriv("sin(x^2) * y", "x") # differentiate only by x
# "2 * (x * y * cos(x^2))"

Deriv("sin(x^2) * y", cache.exp=FALSE) # differentiate by all variables (here by x and y)
"c(x = 2 * (x * y * cos(x^2)), y = sin(x^2))"

# Compound function example (here abs(x) smoothed near 0)
fc <- function(x, h=0.1) if (abs(x) < h) 0.5*h*(x/h)**2 else abs(x)-0.5*h
Deriv("fc(x)", "x", cache.exp=FALSE)
# "if (abs(x) < h) x/h else sign(x)"

# Example of a first argument that cannot be evaluated in the current environment:
  suppressWarnings(rm("xx", "yy"))
  Deriv(xx^2+yy^2)
# c(xx = 2 * xx, yy = 2 * yy)

# Automatic differentiation (AD), note itermediate variable 'd' assignment
Deriv(~{d <- ((x-m)/s)^2; exp(-0.5*d)}, "x")
# Note that the result we see does NOT match what follows
#{
#   d <- ((x - m)/s)^2
#   .d_x <- 2 * ((x - m)/s^2)
#   -(0.5 * (.d_x * exp(-(0.5 * d))))
#}

# Custom derivation rule
  myfun <- function(x, y=TRUE) NULL # do something usefull
  dmyfun <- function(x, y=TRUE) NULL # myfun derivative by x.
  drule[["myfun"]] <- alist(x=dmyfun(x, y), y=NULL) # y is just a logical
  Deriv(myfun(z^2, FALSE), "z")
  # 2 * (z * dmyfun(z^2, FALSE))

# Differentiation by list components
  theta <- list(m=0.1, sd=2.)
  x <- names(theta)
  names(x)=rep("theta", length(theta))
  Deriv(~exp(-(x-theta$m)**2/(2*theta$sd)), x, cache.exp=FALSE)
# c(theta_m = exp(-((x - theta$m)^2/(2 * theta$sd))) *
#  (x - theta$m)/theta$sd, theta_sd = 2 * (exp(-((x - theta$m)^2/
#  (2 * theta$sd))) * (x - theta$m)^2/(2 * theta$sd)^2))

```


### Ryacas

The structures for using yacas tools do not seem at the time of writing
(2016-10-21) to be suitable for working with nonlinear least squares or
optimization facilities of **R**. Thus, for the moment, we will not pursue
the derivatives available in `Ryacas`.


- ?? any others




## Derivatives table

See specific notes either in comments or at the end.

??? do each example by all methods and by numDeriv and put in dataframe for later
presentation in a table.

Do we want examples in columns or rows. Probably 1 fn per row and work out
a name for the row that is reasonably meaningful. Probably want an index column
as well that is a list of strings. Can we then act on those strings to automate
the whole setup?


```{r}
require(nlsr)
# require(stats)
# require(Deriv)
# require(Ryacas)

# Various derivatives 

new <- fnDeriv(quote(1 + x + y), c("x", "y"))
old <- deriv(quote(1 + x + y), c("x", "y"))
print(new)
# Following generates a very long line on output of knitr (for markdown)
class(new)
str(new)
as.expression(new)
newf <- function(x, y){
   eval(new)
}
newf(3,5)

print(old)
class(old)
str(old)
oldf <- function(x,y){
    eval(old)
}
oldf(3,5)


```

Unfortunately, the inputs and outputs are not always easily transformed so that the
symbolic derivatives can be found. (?? Need to codify this and provide filters so we
can get things to work nicely.)

As an example, how could we take object **new** and embed it in a function we can then use
in **R**? We can certainly copy and paste the output into a function template, as follows,

```{r}
fnfromnew <- function(x,y){
    .value <- 1 + x + y
    .grad <- array(0, c(length(.value), 2L), list(NULL, c("x", 
    "y")))
    .grad[, "x"] <- 1
    .grad[, "y"] <- 1
    attr(.value, "gradient") <- .grad
    .value
}

print(fnfromnew(3,5))

```

However, we would ideally like to be able to automate this to generate functions and
gradients for nonlinear least squares and optimization calculations. The same criticism
applies to the object **old**

####Another issue: 

If we have x and y set such that the function is not admissible, then 
both our old and new functions give a gradient that is seemingly reasonable. While the
gradient of this simple function could be considered to be defined for ANY values of x and
y, I (JN) am sure most users would wish for a warning at the very least in such cases.

```{r}
x <- NA
y <- Inf
print(eval(new))
print(eval(old))
```

####SafeD

We could define a way to avoid the issue of character vs. expression (and possibly
other classes) as follows:


```{r}
safeD <- function(obj, var) {
   # safeguarded D() function for symbolic derivs
   if (! is.character(var) ) stop("The variable var MUST be character type")
   if (is.character(obj) ) {
       eobj <- parse(text=obj)
       result <- D(eobj, var)
   } else {
       result <- D(obj, var)
   }
}

lxy2 <- expression(log(x+y^2))
clxy2 <- "log(x+y^2)"
try(print(D(clxy2, "y")))
print(try(D(lxy2, "y")))
print(safeD(clxy2, "y"))
print(safeD(lxy2, "y"))
```

### Derivatives table - 2

```{r}
## Try different ways to supply the log function
aDeriv <- Deriv(log(x), "x")
class(aDeriv)
aDeriv
aderiv <- try(deriv( ~ log(x), "x"))
class(aderiv)
aderiv
aD <- D(expression(log(x)), "x")
class(aD)
aD
cat("but \n")
try(D( "~ log(x)", "x")) # fails -- gives NA rather than expected answer due to quotes
try(D( ~ log(x), "x"))
interm <- ~ log(x)
interm
class(interm)
interme <- as.expression(interm)
class(interme)
try(D(interme, "x"))
try(deriv(interme, "x"))
try(deriv(interm, "x"))


Deriv(log(x, base=3), "x" ) # OK
try(D(expression(log(x, base=3)), "x" )) # fails - only single-argument calls supported
try(deriv(~ log(x, base=3), "x" )) # fails - only single-argument calls supported
try(deriv(expression(log(x, base=3)), "x" )) # fails - only single-argument calls supported
try(deriv3(expression(log(x, base=3)), "x" )) # fails - only single-argument calls supported
fnDeriv(quote(log(x, base=3)), "x" )

Deriv(exp(x), "x")
D(expression(exp(x)), "x") # OK
deriv(~exp(x), "x") # OK, but much more complicated
fnDeriv(quote(exp(x)), "x")

Deriv(sin(x), "x")
D(expression(sin(x)), "x")
deriv(~sin(x), "x")
fnDeriv(quote(sin(x)), "x")

Deriv(cos(x), "x")
D(expression(cos(x)), "x")
deriv(~ cos(x), "x")
fnDeriv(quote(cos(x)), "x")

Deriv(tan(x), "x")
D(expression(tan(x)), "x")
deriv(~ tan(x), "x")
fnDeriv(quote(tan(x)), "x")

Deriv(sinh(x), "x")
D(expression(sinh(x)), "x")
deriv(~sinh(x), "x")
fnDeriv(quote(sinh(x)), "x")

Deriv(cosh(x), "x")
D(expression(cosh(x)), "x")
deriv(~cosh(x), "x")
fnDeriv(quote(cosh(x)), "x")

Deriv(sqrt(x), "x")
D(expression(sqrt(x)), "x")
deriv(~sqrt(x), "x")
fnDeriv(quote(sqrt(x)), "x")

Deriv(pnorm(q), "q")
D(expression(pnorm(q)), "q")
deriv(~pnorm(q), "q")
fnDeriv(quote(pnorm(q)), "q")

Deriv(dnorm(x, mean), "mean")
D(expression(dnorm(x, mean)), "mean")
deriv(~dnorm(x, mean), "mean")
fnDeriv(quote(dnorm(x, mean)), "mean")

Deriv(asin(x), "x")
D(expression(asin(x)), "x")
deriv(~asin(x), "x")
fnDeriv(quote(asin(x)), "x")

Deriv(acos(x), "x")
D(expression(acos(x)), "x")
deriv(~acos(x), "x")
fnDeriv(quote(acos(x)), "x")

Deriv(atan(x), "x")
D(expression(atan(x)), "x")
deriv(~atan(x), "x")
fnDeriv(quote(atan(x)), "x")

Deriv(gamma(x), "x")
D(expression(gamma(x)), "x")
deriv(~gamma(x), "x")
fnDeriv(quote(gamma(x)), "x")

Deriv(lgamma(x), "x")
D(expression(lgamma(x)), "x")
deriv(~lgamma(x), "x")
fnDeriv(quote(lgamma(x)), "x")

Deriv(digamma(x), "x")
D(expression(digamma(x)), "x")
deriv(~digamma(x), "x")
fnDeriv(quote(digamma(x)), "x")

Deriv(trigamma(x), "x")
D(expression(trigamma(x)), "x")
deriv(~trigamma(x), "x")
fnDeriv(quote(trigamma(x)), "x")

Deriv(psigamma(x, deriv = 5), "x")
D(expression(psigamma(x, deriv = 5)), "x")
deriv(~psigamma(x, deriv = 5), "x")
fnDeriv(quote(psigamma(x, deriv = 5)), "x")

Deriv(x*y, "x")
D(expression(x*y), "x")
deriv(~x*y, "x")
fnDeriv(quote(x*y), "x")

Deriv(x/y, "x")
D(expression(x/y), "x")
deriv(~x/y, "x")
fnDeriv(quote(x/y), "x")

Deriv(x^y, "x")
D(expression(x^y), "x")
deriv(~x^y, "x")
fnDeriv(quote(x^y), "x")

Deriv((x), "x")
D(expression((x)), "x")
deriv(~(x), "x")
fnDeriv(quote((x)), "x")

Deriv(+x, "x")
D(expression(+x), "x")
deriv(~ +x, "x")
fnDeriv(quote(+x), "x")

Deriv(-x, "x")
D(expression(- x), "x")
deriv(~ -x, "x")
fnDeriv(quote(-x), "x")

Deriv(abs(x), "x")
try(D(expression(abs(x)), "x")) # 'abs' not in derivatives table
try(deriv(~ abs(x), "x"))
fnDeriv(quote(abs(x)), "x")

Deriv(sign(x), "x")
try(D(expression(sign(x)), "x")) # 'sign' not in derivatives table
try(deriv(~ sign(x), "x"))
fnDeriv(quote(sign(x)), "x")
```

### Notes:

- the base tool deriv (and likely deriv3 ?? need to explore and explain) and 
nlsr::fnDeriv are intended to output a function to compute a derivative. 
deriv generates an expression object, while fnDeriv will generate a language object. 
Do we need to explain this more??  Note that input to deriv is of the form of a 
tilde expression with no left hand side, while fnDeriv uses a quoted expression. ?? We
should explore more ways to input things to these tools. 

- the base tool D and nlsr::Deriv generate expressions, but D requires an
expression, while Deriv can handle the expression without a wrapper. ?? Do we need 
to discuss more??

- nlsr includes abs(x) and sign(x) in the derivatives table despite conventional
wisdom that these are not differentiable. However, abs(x) clearly has a defined
derivative everywhere except at x = 0, where assigning a value of 0 to the 
derivative is almost certainly acceptable in computations. Similarly for sign(x).

### Simplifying algebraic expressions
 
**nlsr** also includes some tools for simplification of algebraic expressions.
Such simplification does not appear to be available / exposed in the 


```{r}
# Various simplifications

Simplify(quote(+(a+b)))
Simplify(quote(-5))
Simplify(quote(--(a+b)))

Simplify(quote(exp(log(a+b))))
Simplify(quote(exp(1)))

Simplify(quote(log(exp(a+b))))
Simplify(quote(log(1)))

Simplify(quote(!TRUE))
Simplify(quote(!FALSE))

Simplify(quote((a+b)))

Simplify(quote(a + b + 0))
Simplify(quote(0 + a + b))
Simplify(quote((a+b) + (a+b)))
Simplify(quote(1 + 4))

Simplify(quote(a + b - 0))
Simplify(quote(0 - a - b))
Simplify(quote((a+b) - (a+b)))
Simplify(quote(5 - 3))

Simplify(quote(0*(a+b)))
Simplify(quote((a+b)*0))
Simplify(quote(1L * (a+b)))
Simplify(quote((a+b) * 1))
Simplify(quote((-1)*(a+b)))
Simplify(quote((a+b)*(-1)))
Simplify(quote(2*5))

Simplify(quote((a+b) / 1))
Simplify(quote((a+b) / (-1)))
Simplify(quote(0/(a+b)))
Simplify(quote(1/3))

Simplify(quote((a+b) ^ 1))
Simplify(quote(2^10))

Simplify(quote(log(exp(a), 3)))

Simplify(quote(FALSE && b))
Simplify(quote(a && TRUE))
Simplify(quote(TRUE && b))

Simplify(quote(a || TRUE))
Simplify(quote(FALSE || b))
Simplify(quote(a || FALSE))

Simplify(quote(if (TRUE) a+b))
Simplify(quote(if (FALSE) a+b))

Simplify(quote(if (TRUE) a+b else a*b))
Simplify(quote(if (FALSE) a+b else a*b))
Simplify(quote(if (cond) a+b else a+b))

# This one was wrong...
Simplify(quote(--(a+b)))

```

### Comparison with other approaches

There is at least one other symbolic package for R. Here we look at 
**Ryacas**. The following example was provided by Gabor Grothendieck.

```{r}
require(nlsr)
dnlsr <- nlsr::Deriv(sin(x+y), "x")
print(dnlsr)
class(dnlsr)

require(Ryacas)
x <- Sym("x")
y <- Sym("y")
dryacas <- deriv(sin(x+y), x)
print(dryacas)
class(dryacas)

```



### check modelexpr() works with an ssgrfun ??

### test model2rjfun vs model2rjfunx ??


### Need more extensive discussion of Simplify??


## Issues of programming on the language

?? need to explain where Deriv package comes from

One of the key tasks with tools for derivatives is that of taking objects
in one or other form (that is, **R** class) and using it as an input for
a symbolic function. The object may, of course, be an output from another
such function, and this is one of the reasons we need to do such 
transformations.

We also note that the different tools for symbolic derivatives use slightly
different inputs. For example, for the derivative of log(x), we have

```{r}
require(nlsr)
dlogx <- nlsr::Deriv(log(x), "x")
str(dlogx)
print(dlogx)
```

Unfortunately, there are complications when we have an 
expression object, and 
we need to specify that we do NOT execute the *substitute()* function. 
Here we
show how to do this implicitly and with an explicit object.

```{r}
require(nlsr)
dlogxs <- nlsr::Deriv(expression(log(x)), "x", do_substitute=FALSE)
str(dlogxs)
print(dlogxs)
cat(as.character(dlogxs), "\n")
fne <- expression(log(x))
dlogxe <- nlsr::Deriv(fne, "x", do_substitute=FALSE)
str(dlogxe)
print(dlogxe)


# base R
dblogx <- D(expression(log(x)), "x")
str(dblogx)
print(dblogx)

require(Deriv)
ddlogx <- Deriv::Deriv(expression(log(x)), "x")
str(ddlogx)
print(ddlogx)
cat(as.character(ddlogx), "\n")
ddlogxf <- ~ ddlogx
str(ddlogxf)
```

## Indexed parameters or variables

Erin Hodgess on R-help in January 2015 raised the issue of taking the 
derivative of an expression that contains an indexed variable. We
show the example and its resolution, then give an explanation.

```{r}
zzz <- expression(y[3]*r1 + r2)
try(deriv(zzz,c("r1","r2")))
require(nlsr)
try(nlsr::Deriv(zzz, c("r1","r2")))
try(fnDeriv(zzz, c("r1","r2")))
newDeriv(`[`(x,y), stop("no derivative when indexing"))
try(nlsr::Deriv(zzz, c("r1","r2")))
try(nlsr::fnDeriv(zzz, c("r1","r2")))
```

Richard Heiberger pointed out that internally, **R** stores

    y[3]

as

    "["(y,3)

that is, as a function. Duncan Murdoch pointed out the availability of
**nlsr** and the use of newDeriv() to redefine the "[" function for
the purposes of derivatives. 

This is not an ideal resolution, especially as we would like to be able
to get the gradients of functions with respect to vectors of parameters
(Noted also by Sergei Sokol in the manual for package **Deriv**). The 
following examples illustrate this.




```{r}
try(nlsr::Deriv(zzz, "y[3]"))
try(nlsr::Deriv(y3*r1+r2,"y3"))
try(nlsr::Deriv(y[3]*r1+r2,"y[3]"))
```


# References
